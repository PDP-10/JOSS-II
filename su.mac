	TITLE JOSS SUPERVISOR 8/1/67 COPYRIGHT 1966 THE RAND CORP.
;PG 1.
;			JOSS SUPERVISORY UNIT
	
;			G. E.  BRYAN


;		THIS CODE PROVIDES FOR THE JOSS SYSTEM THOSE FUNCTIONS
;		THAT ARE GENERALLY DESCRIBED BY THE TERMS EXECUTIVE, MONITOR,
;		OR SYSTEM SUPERVISOR.  IN PARTICULAR, THESE ROUTINES PRO-
;		FOR HANDLING OF I/O INTERRUPTS (FROM DRUM, TAPE, CONSOLE
;		TTY, AND CENTRAL PROCESSOR), RECOVERY FROM MACHINE
;		ERROR, SCHEDULING OF PROCESSOR TIME AND CORE SPACE, MONITOR-
;		ING OF USER AND SYSTEM PERFORMANCE, AND THE LOG-ON AND LOG-
;		OFF PROCESSES.


;		ASSEMBLED 8/1/67 FROM TAPE 56 (A SEQUENCED COPY OF 31)
;		BINARIES ARE ON TAPE 24, CALLED SU.

		PATCH:	BLOCK	20

;PG. 2 - SUPERVISOR ASSEMBLY PARAMETERS
SUBTTL  SUPERVISOR ASSEMBLY PARAMETERS
	
;	SYSTEM PARAMETERS

	N.PP1=20;	LENGTH OF THE PUSH-POP LINKAGE LIST
	N.S=^D40;	ASSEMBLED NUMBER OF STATIONS
	S.M=2;		NUMBER OF 32 BIT GROUPS FOR SIGNAL TABLES
	;		(FP (N.S/32)=0:N.S/32;IP (N.S/32)+1)
	N.SG=N.S;	LENGTH OF THE SIGNAL TABLE
	BUFSIZ=^D18;	BUFFER SIZE
	N.COR=^D16;			# OF CORE BLOCKS AVAILABLE TO USERS
	BBLOCK=^D16;			BEGINNING USER BLOCK
	DELTA=4
	K2=N.S+DELTA;	NUMBER OF BUFFERS ASSEMBLED
	K1=^D60;				THE NUMBER OF TICKS PER SECOND.
	K3=^D15;			DISPLAY INITIALS IF FP(MIN/K3)=0
	SA=112

	;	ASSEMBLY PARAMETERS FOR THE PI CHANNELS

	CDC=1;		1 - DATA CONTROL
	CDRM=2;		2 - I/O PROCESSOR AND DRUM CHANNEL
	CI630=3;	3 - 630 INPUT
	CO630=4;	4 - 630 OUTPUT
	CDAT=6;		INTERRUPT CHANNEL FOR TAPE
	CCTY=6;		6 - CONSOLE TELETYPE
	CAPR=7;		7 - PROCESSOR INTERRUPTS

	CHDC=100;	THESE ARE CORRESPONDING DEFINITIONS FOR PI CONOS
	CHDRM=40;
	CH630=30
	CHDAT=0
	CHCTY=2
	CHAPR=1
	MTC=220;	DEVICE CODES FOR MAG TAPE REGISTERS
	MT1=224
	MT2=230
	DR=400
	DP=010
	DMT=20;		DATA CONTROL DEVICE NUMBER FOR MAG TAPE



;PG.3 - SUPERVISOR ASSEMBLY PARAMETERS
		
	,		REGISTER ASSIGNMENTS

	A=0
	B=1
	C=2
	D=3
	E=4
	F=5
	G=6
	H=7
	I=10
	J=11
	K=12;		USED BY DISTRIBUTOR
	L=13;		USED BY DISTRIBUTOR
	M=14;		USED BY DISTRIBUTOR
	N=15;		USED BY DISTRIBUTOR
	S=16;		USED FOR STATION INDEX
	PP=17;		PUSH-POP REGISTER


		
;PG. 4 - ASSIGNMENTS FOR PSEUDO DATA SWITCHES

SUBTTL		ASSIGNMENTS FOR PSEUDO DATA SWITCHES
		
	,		PSEUDO DATA SWITCHES (IN SWITCH)

	,		RIGHT HALF

	SDS=200000;	SHUTDOWN SWITCH
	BEEPS=400000;	BEEP SWITCH
	OFFS=100000;	BLAST OFF SWITCH
	DCLOB=40000;	DISC NOT AVAILABLE
	HALTS=20000;	HALT ON ERROR SWITCH
	OLSW=100;	HALT ON ERROR SWITCH
	PRMES=40;	ADMINISTRATIVE MESSAGE HAS PRIORITY
	DSTAT=20;	DISPLAY STATISTICAL DISTRIBUTIONS
	DOAF=10;	DISPLAY ONS AND OFFS
	TPQ=4;		DISABLE MAG TAPE OUTPUT
	DUI=2;		DISPLAY USERS INITIALS
	DAM=1;		DISPLAY ADMINISTRATIVE MESSAGE

	;		LEFT HALF

	;		RIGHT 6 BITS ARE STAT LINE NUMBER FOR DISPLAY
		


;PG. 5 - MACRO AND OPERATION DEFINITIONS

SUBTTL MACRO AND OPERATION SWITCHES
		
		DEFINE FSW (N)
	<MOVE A,SWITCH
	>
		DEFINE XMT (M,A); TRANSMIT M CHARACTERS FROM A
	<OPDEF X[M'B12]
	X A>
				
		DEFINE ZBLOK (N)
		<REPEAT N,
		<Z
		XLIST>
		LIST>
				DEFINE QCT(Q,C); MACRO TO COUNT QUEUES
		<
		HRRZ B,Q
		TSX QCTR
		MOVEM A,C>
			
				OPDEF	INS[10B8]
				OPDEF	CHS[20B8]
				OPDEF	SEND[30B8]
				OPDEF	HALT[40B8]
				OPDEF	TALLY[AOS 0]
				OPDEF	NOP[JFCL]
				OPDEF	DONE[POPJ PP,0]
				OPDEF	TSX[PUSHJ PP,0]
				OPDEF	CALL[PUSHJ PP,0]


;PG. 6 - INTERNS AND EXTERNS

SUBTTL INTERNS AND EXTERNS
			
				EXTERN	 C20,C27,C28,T80,T80.99
				EXTERN	 FILE,KEY,PROG
				EXTERN	 DBUF
				EXTERN	 DISC.D,ACTION,RESULT
				EXTERN	 C30,C31,DISC.C,DISC.S
				EXTERN	 SHUT
				EXTERN	 INTENT,INTBEG,SEQ,RISIG,INITIALS,JOBNO
				EXTERN	 PAGNO,ONTIME,COMTIM
				EXTERN	 USIZE
				EXTERN	 SPARE1,SPARE2,CONSOL
				EXTERN	 SPARE3,SPARE4
				EXTERN	 DDT,D.TIME,DUMP,DATIME,RJD,WJD
				EXTERN	 INTENT;			LOC.  IN USER AREA TO START THE PROG.
				EXTERN	 SWITCH,FAKE
				EXTERN	 C32
				
				INTERN	 DATE,HR,MIN,TIME
				INTERN	 CTD,CTDR,CTDB
				INTERN	 CT24,CT17,CT23,CT37
				INTERN	 CT14,CT19,CT18
				INTERN	 CT15,CT22
				INTERN	 CT27A,CT27B,CT46,CT47
				INTERN	CT22A,CT18A,CT18B,TERASE,S.S,N.CB
				INTERN	YEAR,MONTH,DAY,SEC,CT22A
				INTERN	 S.OK
				INTERN	 N.SON,APRR,PROP
				INTERN	 CT11,CT13,CT16,CT28,CT31
				INTERN	 DRMR,S.QUE,CMESS,ADATE,OCTW
				INTERN	 T8,KILL
				INTERN	 S.BUF,COMEBACK,N.S,SIGTBL,SG.L,SG.M,SG.LIM
				INTERN	 USERS,MONENT,T7.9
				INTERN	 CORE,SECONDS,CTYR
				INTERN	 HMES,PPW,TYPE6,SOUT,SIGPR
				INTERN	 SSIG,RSIG,TSIG
				INTERN	 T9,T10,T11,T11.1,T11.2,T11.3,T11.4,T11.5
				INTERN	 T11.6,T11.7,T11.8,T11.9		


;PG. 7 - SUPERVISOR STORAGE
	
SUBTTL SUPERVISOR STORAGE

;	SYSTEM STORAGE

	PPSAV:	Z;				MONITOR PUSH-POP REGISTER SAVE
	CUI:	Z;				CURRENT USER # IN RIGHT HALF
	TYPE6:	XWD		^D9,6;		CONTROL WORD FOR INITIALIZATION RECORD
	DATE:	ASCII		$1/17/67	$

	ATIM:	ASCII		$23:57$
	YEAR:	DEC		0
	MONTH:	DEC		1
	DAY:	DEC		17
	HR:	DEC		23
	MIN:	DEC		57
	SEC:	Z;			SECONDS IN THIS MINUTE
	TICK:	Z;			TICKS IN THIS SECOND
	CL9:	Z;			REG C - PROCESSOR INTERRUPT ROUTINE
	CL10:	Z;			REG D
	CL11:	Z;			INDIRECT ADDRESS CHAIN COUNT
	CL12:	Z;			LOCATION COUNTER
	CL13:	Z;			COUNT OF INTERRUPTS AT SAME LOCATION
	TIME:	Z;			CURRENT TIME IN TICKS. (16 2/3MS=1/60 SEC)
	T.CU:	Z;			TIME USED BY CURRENT USER THIS SHOT.
	SECONDS:Z;		TICKS--CONTINUOUS COUNT FOR TIMER COMPUTATION

	SIGTBL:	REPEAT		N.SG,;		DISTRIBUTION-MONITOR  SIGNAL LIST
	<Z
	XLIST>
	;Z
	;XLIST
		
	SG.L:	Z;				CURRENT NUMBER OF ENTRIES IN SIGTBL
	SG.M:	DEC		N.SG;		MAX # ENTRIES IN SIGTBL
	SG.LIM: DEC		5;		SIGTBL ENTRIES BEFORE COMEBACK (EXCEPT CR)
	
	PPW:	XWD		-N.PP1,PP1-1
	PP1:	REPEAT		N.PP1,;		PUSH-POP LINKAGE LIST
	<Z
	XLIST>
	;Z
	;XLIST

	;	STATE QUEUE ENTRY WORDS

	S.Q:	REPEAT	N.S-1,
	<XWD 0,.+1
	XLIST>
	;XWD 0,+.1
	;XLIST
	Z;					LAST QUEUE ENTRY WORD



; PG. 8 - SUPERVISOR STORAGE

	,	STATION STATUS CELLS

	S.S:		REPEAT N.S,
	<BYTE (6)OF.S,0,0,1,0,0
	XLIST>

		
		S.STA:	POINT 6,S.S(S),5;		CURRENT STATE	(5 BITS)
		S.TM:	POINT 6,S.S(S),^D11;		TIME IN SHOT	(4 BITS)
		S.COR:	POINT 6,S.S(S),^D17;		CORE LOCATION	(5 BITS)
		S.BLOCK:POINT 6,S.S(S),^D23;		NUMBER OF BLOCKS (2 BITS)
		S.OFR:	POINT	1,S.S(S),^D24;	OFF SIGNAL RECEIVED
		S.INR:	POINT	1,S.S(S),^D25;	IN SIGNAL RECEIVED
		S.DU:	POINT	1,S.S(S),^D26;	USING DISC
		S.GK:	POINT	1,S.S(S),^D27;	  SET WHEN USER IS GRONKED
		S.SIG:	POINT	1,S.S(S),^D28;	SET WHEN WAITING FOR SIGNALS

		,	CORE MAP

		CORE:	ZBLOK N.COR; THE CORE MAP
		N.CB:	DEC	4;			MAX # OF CORE BLOCKS PER USER
		N.C:	DEC	N.COR;			# OF ACTIVE CORE BLOCKS  (HIGHEST # NOT TO USE)
		S.IU:	POINT	1,CORE(B),0;		USE BIT FOR BLOCK
		S.ID:	POINT	1,CORE(B),0;		IN USE BY DRUM
		S.UD:	POINT	2,CORE(B),1;		BOTH ACTIVITY IN BITS
		S.UR:	POINT	6,CORE(B),^D8;		USER NUMBER FOR THE BLOCK

		,	SYSTEM PARAMETERS

		N.DRM:	Z;				NUMBER OF USERS ON DRUM
		DBASE:	OCT	20;			BASE TRACK FOR USER BLOCKS
		N.UC:	DEC	1;			START COMPUTING IF ONLY THIS MANY BUFFERS
		N.CK:	DEC	2;			QUIT COMPUTING IF THIS MANY BUFFERS FILLED
		N.SON:	DEC	40;			MAX # OF USERS BEFORE QUEUE MESSAGE
		S.OK:	OCT	47;			IGNORE SIGNALS FROM HIGHER STATIONS
		T.MAX:	DEC	12;			MAXIMUM SHOT TIME ... 200 MS.


;PG. 9 - ASSIGNMENTS FOR I/O BUFFERS

SUBTTL ASSIGNMENTS FOR I/O BUFFERS

		DT.BUF:Z;				HEADER FOR DIS AND TAPE I/O
		CO.BUF: Z;				HEADER FOR CONSOLE TTY OUTPUT
		S.BUF:  ZBLOK N.S;		BUFFER HEADERS: RIGHT = FIRST; LEFT=LAST
		N.BUF:	DEC	K2;			NUMBER OF AVAILABLE BUFFERS.
		L.BUF:	XWD	LASTB,BUF;		HEAD OF AVAILABLE BUFFER LIST

		,	THE I/O BUFFERS

		BUF:	REPEAT K2-1,
		 <XWD	0,.+1+BUFSIZ
		 BLOCK	BUFSIZ
		XLIST>
		LASTB:	XWD	0,0
			BLOCK	BUFSIZ;			THE LAST BUFFER


;PG. 10 - MONITOR SWITCHES

SUBTTL MONITOR SWITCHES

		DMBY: 	 Z;			SET WHEN DRUM IS BUSY
		DKBY:	 Z;			SET WHEN DISC IS BUSY
		COMEBACK:Z;			SET TO REQUEST INTERPRETER RETURN TO MONITOR
		MISC:	 Z;			SWITCH USED BY XMTR, DCOMP, TRST, ADIS, RUL
		CSS:	 Z;			       	       	SWITCH FOR CHS TO TOP OF LIST
		CKF:	 DEC:			0;		SET TO DO CHECKSUMS OF THE DRUM




; PG.11 - STATE QUEUE HEADERS

SUBTTL STATE QUEUE HEADERS
	
			 DEFINE STAC (A)
			 <IRP (A)<A'.S=A-S.QUE>>
			 ,	 DEFINITIONS FOR THE STATE INDEXES.
			 END.S=37;	   END SIGNAL FOR PARTIAL ORDERING QUEUES


			 ,		   THE ORDER OF TABLE REPRESENTS SWAP PRIORITIES
			 S.QUE=.
			 TOF:	  Z;		       WAITING FOR TERMINAL "OFF" PROCESSING
			 ON:	  Z;		       WAITING FOR "ON" PROCESSOR
			 RC:	  Z;		       CARRIAGE RETURN
			 RI:	  Z;		       REQUEST IN (INTERRUPT BUTTON)
			 RIB:	  Z;		       REQUEST IN--NEEDS A BUFFER
			 UC:	  Z;		       UNCHOKE
			 QC:	  Z;		       QUEUE FOR MORE CORE
			 COM:	  Z;		       COMPUTE

			 CU:	  Z;		       CURRENT USER

			 DCT:	  Z;		       WAITING FOR DISC CONTINUE
			 DIP:	  Z;		       DISC ACTION IN PROGRESS
			 CK:	  Z;		       CHOKED ON OUTPUT
			 DQ:	  Z;		       QUEUE FOR ACCESS TO THE DISC
			 GR:	  Z;		       GREEN (CONSOLE INPUTTING)
			 DSU:	  Z;		       DRAINING BUFFERS FOR SWITCH TO USER
			 ABG:	  Z;		       AWAITING A BUFFER FOR GREEN
			 QP:	  Z;		       PAUSE QUEUE
			 QDM:	  Z;		       QUEUE FOR TRANSFER TO DRUM
			 QM:	  Z;		       QUEUE FOR JOSS INITIAL SERVICE
			 OF:	  XWD    S.Q+N.S-1,S.Q; STATION OFF

			 	  STAC <TOF,ON,RC,RI,RIB,UC,QC,COM,CU>
				  STAC <DCT,DIP,CK,DQ,GR,DSU,ABG,QP,QDM,QM,OF>
			 ,	  ALSO STATE RELATED TABLES AT T1,T10,SI1,S10,BOF10.
			 ,                          S10,S11,S12


; PG.12 - STATE ACTION FOR INTERPRETER ENTRY

SUBTTL STATE ACTION FOR INTERPRETER ENTRY

			 ,	   ACTION BIT DEFINITIONS


			 CORBIT=20;	  CORE BIT
 			 DKBIT=10;	  DISC BIT
			 RCBIT=1;	  CARRIER RETURN BIT
			 INBIT=2;	  INTERRUPT BIT
			 BUFBIT=4;	  BUFFER REQUEST BIT
			 ONBIT=40;	  ON STATE BIT

  			 ,          ACTION TABLE - TYPE AND ENTRY

			 T10.:
				    XWD	   0,EJ;	   TOF
				    XWD	   ONBIT,BJ;	   ON
				    XWD	   RCBIT,INTENT;   RC
				    XWD	   INBIT,INTENT;   RI
				    XWD	   BUFBIT+INBIT,INTENT;		RIB
				    XWD	   BUFBIT,INTENT;  UC
				    XWD	   CORBIT,INTENT;  QC
				    XWD	   0,INTENT;	   COM


; PG. 13 - LOG-ON SCANNER STORAGE

SUBTTL LOG-ON SCANNER STORAGE

			SCP1:	 POINT  7,0;	       	  	   	   INPUT BYTE BUFFER
			SCP2:	 POINT 4,CART(B);			   CODE TABLE BYTE POINTER
			SCP3:	 POINT 7,0;				   OUTPUT BYTE POINTER
			SCP4:	 POINT 6,SCP2,5;			   POINTER TO POSITION PART
			SC9:	 NOP   0,0(B);				   POINTER TO EXECUTE TABLE



;PG.14 - COUNTERS FOR ACCOUNTING, STATISTICS, AND DEBUGGING

SUBTTL COUNTERS FOR ACCOUNTING, STATISTICS, AND DEBUGGING

			CT10:	Z;			   	   	    MINUTE
			CT10A:	Z;					    HOUR
			CT32:	Z;					    U - USERS
			CT33:	Z;					    GQ - GREEN STATION QUEUE
			CT2=.
			CT34:	Z;					    CQ - COMPUTE QUEUE
			CT35:	Z;					    BQ - BUFFER, OR CHOKE QUEUE
			CT28:	Z;					    Q - THE QUEUE
			CT13:	Z;					    COM - CHARGED COMPUTER TIME
			CT14:	Z;					    ST - STATEMENTS INTERPRETED
			CT15:	Z;					    A - UNUSED
			CT27:	Z;					    I - IN REQUESTS
			CT16:	Z;					    TL - LINES TRANSMITTED TO USERS
			CT37:	Z;					    B - BACKSPACES RECEIVED FROM USERS
			CT31:	Z;					    CR - LINES RECEIVED FROM USERS
			CT2A=.
			CT25:	Z;					    1 - COUNTER ONE
			CT26:	Z;					    2 - COUNTER TWO
			CT27A:	Z;					    3 - COUNTER THREE
			CT27B:	Z;					    4 - COUNTER FOUR
			CT12:	Z;					    U - UNOVERLAPPED I/O TIME (DRUM)
			CT11:	Z;					    RP - IDLE LOOP COUNT
			CT39:	Z;					    IC - USERS IN CORE
			CT19A:	Z;					    SW - DRUM SWAPS
			CT18:	Z;					    S - SAVES
			CT18A:	Z;					    D - DELETES
			CT18B:	Z;					    DI - PRINT DICTIONARY
			CT19:	Z;					    L - LOADS FROM DISC
			CT17:	Z;					    SR - STATUS RESPONSES
			CT23:	Z;					    SE - STATUS ERRORS
			CT43:	Z;					    1/100TH % OF AVAIL TIME SPENT ON USERS
			CT44:	Z;					    TOTAL COMPUTE TIME FOR USERS SINCE BEGIN
			CT3A=.
			CT46:	Z;					    INPUT INTERRUPTS
			CT47:	Z;					    OUTPUT INTERRUPTS
			CT48A:	Z;					    CELLS FOR DISPLAY OF SIZE DISTR.
			CT48B:	Z;
			CT48C:	Z;



;PG. 15 - COUNTERS FOR ACCOUNTING, STATISTICS, AND DEBUGGING

			CT7=.
			CT41:	Z;					    T - TAPE REWRITE TRIES
			CT42:	Z;					    E - TAPE ERASES
			CT45:	Z;					    - - UNERASABLE TAPE
			CT21:	Z;					    D - DRUM ERRORS
			CT22A:	Z;					    K - DISC ERRORS
			CT22:	Z;					    C - CONSOLE DETECTED PARITY ERRORS
			CT24:	Z;					    S - SCANNER DETECTED PARITY ERRORS
			CT7A=.
			CT50:	Z;						COUNT CORE COMPACTS
			CT49=N.DRM
			TERROR=CT41
			TERASE=CT42
			USERS=CT32



;PG. 16 - COUNTERS FOR ACCOUNTING, STATISTICS, AND DEBUGGING


			;		HEADER LINE FOR CONSOLE TTY OUTPUT

			HEAD:		ASCII /TM UR-GQ-C-B COM-STA I--TL-C/;	30 CHAR
					ASCII /R-CI-CO T-K-T-#-R-#-D T%-RP-U-IC  SW-S-L-D/;  42 CHAR



;PG. 17 - COUNTERS FOR ACCOUNTING, STATISTICS, AND DEBUGGING



                     ;               STORAGE FOR SUMMARY DATA


			      ,	       BLOCKS FOR DISTRIBUTIONAL DATA
			      ,	       COUNTER RANGES READING THE DISPLAY FROM THE LEFT ARE:
			      ,	       >500,500-200,200-100,100-50,50-20,20-10,10-5,5-2,2-1,<



		       ,	       UNITS FOR THE DISPLAYS ARE:
		       ,	       SESSION TIME - MINUTES
		       ,	       COMPUTE TIME - 10 SECONDS
		       ,	       PROGRAM SIZE - CELLS USED
		       ,	       GR-GR   TIME - 1/10 MINUTES
		       ,	       COMP/INTERAC - TICKS


		       SESTIM:  ZBLOK 12;  CUMULATIVE SESSION TIME DISTRIBUTION
			CCTIM:	ZBLOK 12;  CUMULATIVE COMPUTE TIME
			DSIZE:	ZBLOK 12;	*	SIZE
			DTIM:	ZBLOK 12;	*   GREEN-GREEN INTERARRIVAL TIME
			DCPI:	ZBLOK 12;	*	COMPUTE TIME PER INTERACTION
			CPIL:	ZBLOK 12;   CHAR/INPUT LINE
			CPOL:	ZBLOK 12;   CHAR/OUPUT LINE

;PG. 18 - COUNTERS FOR ACCOUNTING, STATISTICS, AND DEBUGGING



			;	CHARACTER (MOSTLY) INTERRUPTS/SECOND/USER
			,	RANGE: >=15,15-7.5,7.5-3,3-1.5, ... , .75-.03,<.03
		
			IINT:	ZBLOK 12;  INPUT INTERRUPTS
			OINT:	ZBLOK 12;  OUTPUT INTERRUPTS
			TINT:	ZBLOK 12;  TOTAL INTERRUPTS
			T5:	ZBLOK 12;  INTERPRETATION RATE
			T6:	ZBLOK 12;  BLOCKSIZE DISTRIBUTION
			T7:	ZBLOK 12;  MISC COUNTS
			T7.9=T7+9
			T8:	ZBLOK 12;  TASK TURN-AROUND TIME
			T9:	ZBLOK 12;  JOE USES T9, T10, AND T11 TO COUNT
			T10:	ZBLOK 12;  COMMAND EXECUTIONS BY VERB TYPE
			T11:	ZBLOK 12
			T11.1=T11+1
			T11.2=T11+2
			T11.3=T11+3
			T11.4=T11+4
			T11.5=T11+5
			T11.6=T11+6
			T11.7=T11+7
			T11.8=T11+8
			T11.9=T11+9


;PG. 19 - COUNTERS FOR ACCOUNTING, STATISTICS, AND DEBUGGING

			,	PER USER COUNTERS
				
			,	RIGHT=COMPUTE TICKS SINCE LAST GREEN
			,	LEFT=TIME OF LAST GREEN

			USTAT:	ZBLOK N.S;	USER COUNTERS

			MINT:	ZBLOK N.S;	CURRENT USERS INITIALS
			LIST
			SUM:	ZBLOK N.S;	USER BLOCK CHECKSUMS



;PG.20 - FIELD SIZE, SCALE FACTOR, AND POINTER FOR COUNTERS

SUBTTL FIELD SIZE, SCALE FACTOR, AND POINTER FOR COUNTERS

			,	IN CTP MACRO:= A# OF COLUMNS (MUST TOTAL <=72)
			,	B=SCALE FACTOR USED BEFORE PRINT
			,	C=CT (OR COUNTER) #
			,	E=0 IF COUNTER IS ZEROED EACH MINUTE
			DEFINE CTP (A,B,C,E)
			<OPDEF CTP2[BYTE (1)E(5)A(12)^D'B]
			CTP2 CT'C>
			CTPAR:CTP 3,1,32,1;	UR - USERS
			CTP 3,1,33;		GQ - GREEN USERS
			CTP 2,1,34;		C - COMPUTING USERS
			CTP 2,1,35;		B - OUTPUT LIMITED USERS
			CTP 4,6,13;		COM- COMPUTE TIME
			CTP 4,10,14;		STA - STATEMENTS INTERPRETED
			CTP 2,1,15,1;		A - IGNORED PARITY ERRORS
			CTP 2,1,50;		M - MORE COMPACTS
			CTP 4,1,16;		TL - LINES TRANSMITTED TO USER
			CTP 3,1,31;		CR - LINES RECEIVED FROM USERS
			CTP 3,10,25;		CI - CHARACTERS INPUT
			CTP 3,100,26;		CO - CHARACTERS OUTPUT
			CTP 2,1,41,1;		T - TAPE ERRORS
			CTP 2,1,22A,1;		K - DISC ERRORS



;PG. 21 - FIELD SIZE, SCALE FACTOR, AND POINTER FOR COUNTERS
		
			
			CTP 2,1,27A;		P - LAST STATION TO TRANSMIT PARITY ERROR
			CTP 2,1,22;		C - CONSOLE PARITY ERRORS
			CTP 2,1,27B;		B - LAST STATION TO TRANSMIT A BAD CHARACTER
			CTP 2,1,24;		S - SCANNER PARITY ERRORS
			CTP 2,1,21,1;		D - DRUM ERRORS		
			CTP 3,100,43,1;		1/100% COMPUTE TIME - RESET EACH HOUR (LOGS AS %)
			CTP 3,2000,11;		ID - IDLE LOOP COUNT
			CTP 2,1,12;		U - UNOVERLAPPED I/O COUNTS
			CTP 3,1,39,1;		OD - USERS IN CORE
			CTP 4,1,19A;		SW - DRUMS READS+WRITES
			CTP 2,1,18;		S - DISC SAVES
			CTP 2,1,19;		L - DISC LOADS
			CTP 2,1,18A;		D - DISC DISCARDS
			CTPARS=.-CTPAR			 

;PG 22
SUBTTL DATA CONTROL INTERRUPT ROUTINE

DISMIS: Z;			DATA CONTROL END ROUTINE
	CONO	PI,1000+CHDC;	TURN OFF CHANNEL
	JRST	12,@DISMIS

;PG 23
SUBTTL DRUM CHANNEL INTERRUPT ROUTINES

DRMR:	Z
	SETZM	DRM14;		IF ERROR, FLAG STORED HERE
	CONSZ	DP,100060;
	JRST	DEER;		MISSED DATA, NOEX MEM, OR PARITY ERROR
	SKIPN	DMBY
H15:	HALT	15;		SHOULD BE USING THE DRUM
	CONSO	DP,10
	JRST	DRM3
	CONO	DP,0;		KILL THE INTERRUPT
	JRST	12,@DRMR;	DISMISS END INTERRUPT FROM 167

DRM3:	EXCH	B,DRM9
	EXCH	C,DRM8
	CONSZ	DR,1000;	CHECK FOR ERROR
	JRST	DERR
	MOVEI	B,77777
	ANDM	B,DPWD1;	MASK OUT POSSIBLE HIGH CARRY BIT
	DATAI	DP,B
	CAME	B,DPWD1;	CHECK FOR GOOD
	JRST	DERR
	DATAI	DR,B
	CAME	B,DEDR1;	DRUM REGISTER ENDING CONTENTS
	JRST	DERR
	CONSO	DR,100
H17:	HALT	17;		NO JOB DONE FLAG
	CONO	DR,270;		DESELECT THE DRUM
	SETZM	DMBY
	SKIPN	DMWR;		SKIP IF WRITING
	JRST	10,DRM7;	MUST BE A READ
	SETZM	DECT;		ZERO THE ERROR COUNT

;	WRITE END ROUTINE

	EXCH	S,DRM13
	MOVE	S,DMUSR
	MOVE	C,BLKSWRIT
	MOVE	B,DMIBK
	SETZM	CORE(B);	IDLE THE CORE JUST WRIT
	AOS	B
	SOJG	C,.-2
DR2:	AOS	N.DRM;		COUNT DRUM USERS
	SOS	CT39;		COUNT DOWN USERS IN CORE
	MOVE	B,DMNR;		GET LIST FOR OUT
	TLNE	B,777777;	SKIP IF NO MORE TO GO OUT
	JRST	10,DM10;	GO FOR NEXT WRITE
	SKIPE	SS98;		SKIP IF NO COMPACT REQUEST
	JRST	10,DRM2
	SKIPGE	S,DMIN;		SKIP IF SOME TO COME IN
	JRST	10,DRM4.5
	EXCH	PP,DRMPP
	TSX	ISWAP;		INITIATE IN TRANSFER
	EXCH	PP,DRMPP
	JRST	10,DRM5

;PG 24

;	INTERRUPT END SEQUENCE

DRM4.5: AOS	COMEBACK
DRM5:	EXCH	S,DRM13
DRM6:	EXCH	B,DRM9
	EXCH	C,DRM8
DRM6.5: AOS	CT19A;		COUNT DRUM ACTIONS
	JRST	2,@DRMR

DRM2:	AOS	SS99;		SET REQUEST FOR COMPACT OF CORE
	SETZM	SS98
	AOS	DMBY
	JRST	DRM4.5

;PG 25

;	READ END INTERRUPT

DRM7:	EXCH	S,DMIN
	EXCH	A,DRM14
	HRRZ	B,DMIBK
	ADDI	B,BBLOCK
	LDB	C,S.BLOCK
	LDB	A,S.STA
	CAIN	A,QC.S;		CHECK FOR EXPANDING SIZE
	SUBI	C,1
	JSR	CKSUM;		CHECKSUM THE BLOCK
	CAMN	A,SUM(S)
	JRST	DRM7.5;		GOOD
	EXCH	A,DRM14
	EXCH	S,DMIN
	JRST	DMERR
DRM7.5: SETZM	DECT
	EXCH	A,DRM14
	HRRZ	B,DMIBK
	DPB	S,S.UR
	ADDI	B,BBLOCK
	DPB	B,S.COR;	SET USER CORE LOCATION
	EXCH	A,DRM11;	SAVE REG AND GET A 2
	HRRZ	B,DMIBK
	LDB	C,S.BLOCK
	DPB	A,S.UD;		SET IN CORE AND NO DRUM USE
	AOS	B
	SOJG	C,.-2
	EXCH	A,DRM11
	AOS	CT39
DRM7.6: SOS	N.DRM
DRM7.7: EXCH	S,DMIN
	JRST	DRM6

; PG 26

DRM8:	Z;			SAVE FOR REG C
DRM9:	Z;			SAVE FOR REG B
DRM10:	OCT	1;		SAVE FOR REG A AND A ONE
DRM11:	OCT	2;		SAVE FOR REG A AND A TWO
DRM12:	Z
DRM13:	Z;			SAVE CELL FOR S
DRM14:	Z;			SAVE FOR A
DRMPP:	XWD	-2,.;		LOCAL PUSH REGISTER
	Z



,	INITIATE NEXT WRITE

,	B HAS PP REG FOR REQUEST LIST

DM10:	EXCH	PP,DRMPP
	POP	B,X;		GET NEXT TO WRITE
	LDB	C,S.BLOCK
	EXCH	D,DRM12
	MOVEM	B,DMNR
	EXCH	A,DRM14
	TSX	OSWAP;		START HIM OUT
	EXCH	A,DRM14
	EXCH	D,DRM12
	EXCH	PP,DRMPP
	JRST	DRM5

SUBTTL DRUM ERROR RECOVERY
; PG 27

;	DATA PROCESSOR ERRORS (PARITY, NOEX MEM, DATA MISS)

DEER:	EXCH	B,DRM9
	CONI	DP,B
	HRLM	B,DRM14
	CONO	DP,0
	EXCH	C,DRM8

;	OTHER HARDWARE ERRORS--DC FLAGS AND DATA REGISTER MISCOMPARE

DERR:	CONI	DP,B
	HRRM	B,DRM14;	SAVE FLAGS FOR DISPLAY
	CONO	DR,200270;	DISMISS DRUM
	JRST	10,DMERR

DMERR:	AOS	CT21;		COUNT DRUM ERRORS
	AOS	B,DECT
	CAILE	B,5
	JRST	FAIL
	AOS	DMBY
	SKIPN	DMWR;		SKIP IF WRITE
	JRST	DE10;		GO RECOVER READ ERROR
	CONO	DP,100+CDRM
	DATAO	DP,DPWD
	DATAO	DR,DEDR
	CONO	DR,260
	CONO	DR,220+CDRM
	JRST	DRM6

DE10:	CONO	DP,CDRM
	DATAO	DP,DPWD
	DATAO	DR,DEDR
	CONO	DR,260
	CONO	DR,230+CDRM
	JRST	DRM6

CKER:	Z;			SET IF A GRONKED USER
DECT:	Z;			ERROR RETRY COUNT
DEDR:	Z;			UNIT AND TRACK OF LAST SELECT
DEDR1:	Z;			EXPECTED ENDING TRACK AND SECTOR

; PG 28

;	CANT RECOVER DRUM ERROR--PREPARE TO GRONK USER

FAIL:	EXCH	S,DMIN
	EXCH	A,DRM14
	MOVEM	A,MINT(S);	SAVE FAILING CHECKSUM
	AOS	CKER;		FLAG ERROR OCCURRENCE
	MOVEI	A,1
	DPB	A,S.GK;		FLAG USER AS GRONKED
	EXCH	A,DRM14
	SETZM	DECT
	SETZM	DMBY
	SKIPE	DMWR
	JRST	DRM7.7
	LDB	C,S.BLOCK
	HRRZ	B,DMIBK
	SETZM	CORE(B);	FREE CORE
	AOS	B
	SOJG	C,.-2
	JRST	DRM7.6

SUBTTL CHECKSUM A USERS BLOCK
; PG 29

,		REPORTS ZERO CHECKSUM WHEN CKF IS ZERO
,		C,B CLOBBERED
,		S= USER #, C=BLOCKS TO SUM, B= LOCATION
CKSUM:	Z
	SKIPE	CKF
	JRST	.+3
	MOVEI	A,0
	JRST	2,@CKSUM
	ASH	C,^D10
	SUBI	C,1
	ASH	B,^D10
	HRRM	B,CKS7
	EXCH	7,CKS7
	EXCH	10,CKS10
	EXCH	11,CKS11
	MOVEI	A,0
	JRST	7
CKS5:	EXCH	7,CKS7
	EXCH	10,CKS10
	EXCH	11,CKS11
	JRST	2,@CKSUM


CKS7:	ADD	A,0(C)
CKS10:	SOJGE	C,7
CKS11:	JRST	CKS5

SUBTTL INITIATE TRANSFER TO DRUM
; PG 30

,	C= # OF BLOCKS TO WRITE
,	S= USER TO WRITE
,	DRUM LOCATIONS ARE FIXED BY USER - TWO TRACKS EACH,
,	SO THE MAX SIZE HANDLED IS 16K WORDS PER USER. B,D ARE CLOBBERED

OSWAP:	CONSZ	DR,100
H14:	HALT	14;		DRUM SHOULD BE FREE
	MOVEM	C,BLKSWRIT
	LDB	B,S.COR
	JSR	CKSUM
	MOVEM	A,SUM(S)
	MOVE	C,BLKSWRIT
	ASH	C,6
	MOVEM	C,DEDR1
	ASH	C,4
	MOVEM	C,DPWD1
	MOVE	C,BLKSWRIT
	HRRZ	D,C
	LSH	C,^D28
	MOVNM	C,DPWD;		WORDS TO MOVE
	LDB	B,S.COR
	SUBI	B,BBLOCK
	MOVEM	B,DMIBK;	SAVE LOCATION OF BLOCK WRITTEN
	MOVEI	C,1
	DPB	C,S.ID;		SET DRUM USE BIT
	AOS	B
	SOJG	D,.-2
	LDB	B,S.COR
	ASH	B,^D10
	DPB	B,S.COR;	MARK USER OUT OF CORE
	HRRM	B,DPWD;		FIRST WORD TO TRANSFER
	ADDM	B,DPWD1
	CONO	DP,100+CDRM;	SELECT FOR WRITE AND SET CHANNEL
	DATAO	DP,DPWD;	ACTIVATE I/O PROCESSOR
	HRRZ	B,S
	HRRZM	B,DMUSR
	ADD	B,DBASE
	ASH	B,^D10;		TRACK = 2&USER+DBASE
	MOVEM	B,DEDR;		SAVE UNIT AND TRACK FOR RECOVERY
	DATAO	DR,B;		SET UNIT AND TRACK
	CONO	DR,260;		SELECT UNIT
	CONO	DR,220+CDRM;	WRITE
	ADDM	B,DEDR1
	AOS	DMWR;		INDICATE DRUM WRITE
	AOS	DMBY
	DONE

SUBTTL DATA FOR DRUM TRANSFERS
; PG 31

DMNR:	XWD	0,.;		LIST OF USERS TO WRITE
	ZBLOK 16
DMIBK:	Z;			INCOMING BLOCK NUMBER
DPWD:	Z;			I/O CONTROL WORD
DPWD1:	Z;			EXPECTED END CONTENTS OF 167
DMUSR:	Z;			DRUM USER
DMWR:	Z;	SET WHEN WRITING
DMIN:	Z; RIGHT = USER TAGGED FOR IN, LEFT = PLACE IN QUEUE, NEG IF NO IN
BLKSWR: Z;			# OF BLOCKS WRITTEN

SUBTTL INITIATE TRANSFER FROM DRUM TO CORE
; PG 32

,	S HAS USER TO COME IN; DMIBK= CORE BLOCK FOR "IN"
,	S IS CLOBBERED

ISWAP:	LDB	C,S.BLOCK
	LDB	B,S.STA
	CAIN	B,QC.S;		CHECK FOR SIZE INCREASE
	SUBI	C,1
	MOVEM	S,DMIN
	MOVEM	C,S;		SAVE CORRECT BLOCK SIZE
	LSH	C,^D28
	MOVNM	C,DPWD;		WORD COUNT
	HRRZ	B,DMIBK;	GET IN LOCATION
	ADDI	B,BBLOCK
	ASH	B,^D10
	HRRM	B,DPWD;		FIRST WORD
	HRRZM	B,DPWD1
	HRRZ	B,DMIBK
	MOVE	C,S
	ASH	C,^D10
	ADDM	C,DPWD1
	MOVE	C,S
	ASH	C,6
	MOVEM	C,DEDR1
	MOVE	C,S
	EXCH	A,DRM10
	DPB	A,S.ID;		SET DRUM IN USE
	AOS	B
	SOJG	C,.-1
	SETZM	DMWR
	AOS	DMBY
	MOVE	S,DMIN;		RECOVER USER #
	ADD	S,DBASE
	ASH	S,^D10;		TRACK = 2&USER+DBASE
	CONO	DP,CDRM;	SAY READ AND ASSIGN CHANNEL
	DATAO	DP,DPWD;	ACTIVATE 167
	MOVEM	S,DEDR;		SAVE UNIT AND TRACK FOR RECOVERY
	CONO	PI,400;		PREVENT INTERRUPT FOR A WHILE
	DATAO	DR,S;		UNIT AND TRACK
	CONO	DR,260;		SELECT UNIT
	CONO	DR,230+CDRM;	READ
	EXCH	A,DRM10
	CONO	PI,200;		ON AGAIN
	ADDM	S,DEDR1;	EXPECTED END #
	HRRZS	DEDR1;		ZERO LEFT HALF
	DONE

	SUBTTL	TAPE INTERRUPT ROUTINES
;	PAGE 33

TIP:	CONI 	MT1,TEND4;	 READ IN TAPE FLAGS
	CONSO	MT1,4;		 ERF INTERRUPT?
	JRST	TE20

TEND:	CONO	MT1,0;		DISABLE THE INTERRUPTS
	EXCH	S,TEND5
	EXCH	B,TEND6
	EXCH	E,TEND7;	GIVE ME SOME ELBOW ROOM
	EXCH	PP,TPDL
	MOVE	B,TEND4;	GET THE FLAGS
	TRNE	B,70;		SKIP IF NO ERROR
	JRST	TEND9;		GO FIX THE ERROR
	SETZM	TEND8;		OK, ZERO THE RETRY COUNT
	SKIPE	TEND4;		RESTART DO DONT GIVE BACK BUFFER
	TSX	MBA
	SKIPE	DT.BUF;		SKIP IF NO MORE BUFFERS
TEND1:	TSX	CIO
TEND2:	EXCH	S,TEND5
	EXCH	B,TEND6
	EXCH	E,TEND7
	EXCH	PP,TPDL
	JRST	12,@CTYR

TE20:	SKIPN	TEND8;		SKIP TO IGNORE BKSPACE OR WRITE BLANK
	JRST	TE22;		GO TO TRY TO READY TAPE
TE21:	CONO	MT1,0;		KILL THE INTERRUPT
	JRST	12,@CTYR
TE22:	CONSZ	PI,CHDC;	GET IT LATER IF DATA CONTROL IS BUSY
	JRST	TE21
	CONSO	MT1,2;		SKIP IF TRANSPORT READY
	JRST	TE21;		RETURN WE WILL TRY AGAIN LATER
	SETZM	TEND4;		SET RESTART SIGNAL
	JRST	TEND;		GO DO IT

TEND4:	Z;			FLAG STORAGE
TEND5:	DEC	-2;		SAVE CELL FOR S AND CONTEXT FOR TAPE
TEND6:	Z
TEND7:	Z;			SAVE CELL
TEND8:	Z;			COUNT OF REWRITE TRIES

	SUBTTL	TAPE INTERRUPT ROUTINES
;	PAGE 34

TEND9:	AOS	TERROR;   	COUNT TAPE ERRORS
TEND93:	AOS	B,TEND8;	COUNT REWRITE TRIES
	CONO	MT1,0;		OFF WITH THE LIGHTS
	TSX	TWAIT;		WAIT ON TAPE
	CONO	MTC,CDAT+3400;	BACKSPACE TAPE
	TSX	TWAIT
	CAIG	B,3;		TRY REWRITE 3 TIMES.
	JRST	TEND1

TEND95:	CONO	MTC,CDAT+5400;	WRITE BLANK TAPE
	TSX	TWAIT
	CONSZ	MT1,30;		CHECK FOR NOT ERASED
	AOS	CT45;		COUNT ERASE ERRORS
	AOS	TERASE
	SETZM	TEND8
	JRST	TEND1

TWAIT:	CONSO	MT1,40000;	WAIT FOR COMMAND OK
	JRST	.-1
	CONSO	MT1,2;		AND FOR TAPE READY
	JRST	.-1
	DONE

	SUBTTL	TAPE INTERRUPT ROUTINES
;	PAGE 35

;	MAG TAPE OUTPUT START ROUTINE

CIO:	SKIPE	 SKR;		SKIP IF SKULKER NOT USING DC
	JRST	 CIO1
	SKIPN	 DIP;		NO START IF DISC USING DC
	CONSZ	 MT1,200
	JRST	 CIO1;		CANT WRITE ON FILE PROTECTED TAPE
	CONSO	 MT1,2;		TAPE SHOULD BE READY
	JRST	 CIO1;		TAPE MUST BE READY
	MOVE	 B,[BLKO DC,TCW]
	MOVEM	 B,40+2*CDC;	SET UP DC INTERRUPT ROUTINE
	MOVE	 B,[JSR DISMIS]
	MOVEM	 B,41+2*CDC
	HRRZ	 B,DT.BUF;	ADDRESS OF BUFFER
	HRRM	 B,TCW
	HLRZ	 B,1(B);	GET WORD COUNT
	MOVNS	 B,B
	HRLM	 B,TCW;		NEG COUNT TO CONTROL WORD
	CONO	 MT1,0;		DISABLE ALL, I DONT KNOW WHY!
	CONO	 DC,CDC+DMT+3400; START DATA OUT
	CONO	 MTC,CDAT+71000; START TAPE - BINARY @556 BPI
	CONO	 PI,2000+CHDC;	ENABLE DATA CONTROL
	SETZ	 TAPES
	CONO	 MT1,1;		ENABLE TAPE CONTROL FREE TRAP
	DONE

CIO1:	AOS	TAPES;		SET RESTART FLAG
	DONE

TAPES:	Z;			SET IF TAPE RESTART IN NEEDED
TCW:	Z;			DC CONTROL WORD FOR TAPE
TPDL:	XWD	-2,.;		PUSH LIST DURING INTERRUPT
	Z

,	TAPE RESTART ROUTINE

TRST:	SKIPN	DIP;		NO RESTART IF DISC USING DC
	SKIPN	TAPES
	DONE;			NOR IF NONE INDICATED
	CONSZ	TTY,170;    	SKIP IF NOT BUSY
	JRST	TRST1
	MOVEI	B,"";		  THATS A BELL
	DATAO	TTY,B
TRST1:	SKIPE	DT.BUF;		SKIP IF NOTHING TO START
	TSX	CIO;		START TAPE I/O
	DONE

	SUBTTL	CONSOLE TTY INTERRUPT ROUTINES
;	PAGE 36

;	CHANNEL 6 INTERRUPTS: TTY IN, TTY OUT, AND MAG TAPE

CTYR:	Z
	CONSO	TTY,10;		IS IT AN OUTPUT INTERRUPT?
	JRST	ST41;		MUST BE INPUT
	SKIPN	CO.BUF;		SKIP IF BUFFER ATTACHED
	JRST	ST40
	EXCH	B,ST31;		SAVE REGISTER
	ILDB	B,ST32;		GET NEXT BYTE
	JUMPE	B,ST33;		DISMISS IF END CHARACTER
	DATAO	TTY,B;		OUTPUT CHARACTER
ST34:	EXCH	B,ST31;		RESTORE
	JRST	12,@CTYR;	RETURN AND DISMISS
ST33:	CONO	TTY,200+CCTY;	TURN OFF OUTPUT FLAG
	EXCH	S,ST35
	EXCH	PP,ST22
	EXCH	E,ST24
	TSX	MBA
	SKIPE	CO.BUF;		ARE THERE MORE BUFFERS TO SEND
	TSX	BIO
	EXCH	PP,ST22
	EXCH	E,ST24
	EXCH	S,ST35
	JRST	ST34

ST40:	CONO	TTY,200+CCTY
	JRST	12,@CTYR

ST22:	XWD	-2,.
ST23:	Z;			PDL FOR INTERRUPT ROUTINE
ST24:	Z
ST31:	Z
ST32:	POINT	7,0;		POINTER TO OUTPUT TEXT
ST35:	DEC	-1

;	START ROUTINE FOR CONSOLE TTY OUTPUT

BIO:	HRRZ	B,CO.BUF
	HLL	B,[POINT 7,0]
	ADDI	B,1;		POINTER TO TEXT
	MOVEM	B,ST32;		INITIALIZE
	CONO	TTY,CCTY;	ASSIGN CHANNEL
	ILDB	B,ST32
	DATAO	TTY,B;		START OUT FIRST CHARACTER
	DONE

	SUBTTL	CONSOLE TTY INTERRUPT ROUTINES
;	PAGE 37

;	INPUT INTERRUPT FROM CONSOLE TTY

ST41:	CONSO	TTY,40;		SKIP IF TTY INPUT INTERRUPT
	JRST	TIP;		MUST BE TAPE
	EXCH	B,ST46
	EXCH	E,ST47
	EXCH	PP,ST52
	JUMPN	E,ST42;		JUMP IF WE ALREADY HAVE A BUFFER
	TSX	GETBUF
	JRST	ST45-1;		ITS TOUGH IF NO BUFFERS
	MOVEI	B,^D80;		LIMIT ON NUMBER OF INPUT CHARACTERS
	MOVEM	B,ST51
	HRRM	E,ST48;		SAVE BUFFER ADDRESS
	HLL	E,[POINT 7,0];	MAKE UP POINTER
	AOS	E;	 	TEXT IS WORD ONE
ST42:	DATAI	TTY,B;		READ THE CHARACTER
	IDPB	B,E;		DEPOSIT IN BUFFER
	SOSN	ST51;		COUNT INPUT CHARACTERS
	JRST	.+3;		NOT TOO MANY FOR THE BUFFER NOW
	CAIE	B,215;		SKIP IF CARRIAGE RETURN
	JRST	ST45;		NOT YET - EXIT

	EXCH	D,ST49
	MOVEI	B,0
	MOVE	E,ST48;		GET BUFFER LOCATION
	AOS	E;		TO TEXT
	MOVEM	E,ST50;		SAVE IT
	MOVE	D,[POINT 7,OPMSG]

ST43:	ILDB	E,ST50
	CAIN	E,15;		SKIP IF NOT CARRIAGE RETURN
	JRST	ST44;		CR - END OF LINE
	IDPB	E,D;		PUT CHARACTER IN MESSAGE
	AOS	B
	CAIGE	B,^D30;		SKIP IF ENOUGH CHAR FOR MESSAGE LINE
	JRST	ST43;		GO FOR ANOTHER

ST44:	MOVEM	B,L.OPM;	COUNT OF CHARACTERS IN MESSAGE
	EXCH	D,ST49
	HRRZ	E,ST48;		GET BUFFER POINTER
	TSX	MBA1;		AND GIVE IT BACK
	MOVEI	E,0;		RESET BUFFER SWITCH
	CONO	TTY,CCTY+1000;	OFF WITH THE FLAG!
ST45:	EXCH	E,ST47
	EXCH	B,ST46
	EXCH	PP,ST52
	JRST	12,@CTYR

ST46:	Z;			SAVE REG B
ST47:	Z;			BYTE POINTER FOR INPUT,SAVE REG E, SIGNAL
ST48:	POINT	7,0;		CONSTANT IN LEFT, BUFFER POINTER IN RIGHT
ST49:	Z;			SAVE REG D
ST50:	Z;			HOLDS BYTE POINTER
ST51:	Z;			COUNT OF INPUT CHARACTERS
ST52:	XWD	-2,ST51-1;	PDL POINTER FOR INTERRUPT ROUTINE
	SUBTTL	USER OPERATION (UUO) INTERPRETER
;	PAGE 38

;	     	USES 00X CLASS OF PROGRAMMED OPERATORS, ASSUMES AN OUTPUT
;		POINTER IN C, CLOBBERS A AND B. CHARACTER SHOULD BE ASCII
;		AND MUST BE LEFT JUSTIFIED IN THE "FROM" LOCATION.

PROP:	Z
	EXCH	B,30;		SAVE FOR RECOVERY
	LDB	B,[POINT 3,40,5]; GET OP CODE
	JUMPE	B,XMTR;	 	ZERO IS THE TRANSMITTER
	CAIG	B,4;		TEST RANGE
	JRST	.+1(B);		GO TO PROPER ROUTINE
	JRST	PR1
	JRST	INSR;		INSERT OP
	JRST	R2;		CHANGE STATE
	JRST	R3;		SEND CHAR STRING TO BUFFER
	JRST	R4;		HALT ROUTINE

PR1:	HRRZ	J,PROP
	CAIG	J,INTBEG
	JRST	H3;		GO TO SIMULATE HALT 3
	MOVEI	A,75
	JRST	KILL;		GO TO ELIMINATE THE USER

H3:	MOVEI	B,3;		ILLEGAL UUO--NON-INTERPRETER
	MOVEM	B,40;
	JRST	R4

XMTR:	MOVE	B,[POINT 7,0]
	HRR	B,40
	MOVEM	B,MISC;		POINTER FOR INPUT STRING
	LDB	B,[POINT 7,40,12]; GET "M" THE CHARACTER COUNT
	JUMPE	B,H3;	 	ZERO CHAR COUNT - PROBABLY AN ERROR
	ILDB	A,MISC
	IDPB	A,C;		MOVE THE CHARACTERS
	SOJG	B,.-2
	JRST	2,@PROP;	RETURN FROM PROGRAMMED OP

INSR:	MOVE	A,40;		GET THE CHARACTER
	IDPB	A,C;		DEPOSIT IN OUTPUT STRING
	JRST	2,@PROP;	RETURN

R2:	HRRZ	E,40;		GET DESTINATION STATE
	TSX	CHS.;		GO TO ROUTINE
	JRST	2,@PROP;	RETURN FROM PROGRAMMED OP

R3:	HRL	E,40;		ADDRESS OF CONTROL WORD
	TSX	BJ9.1;		TO SEND ROUTINE
	JRST	2,@PROP

	SUBTTL	HANDLE MACHINE FAILURE HALTS -- TRY TO RECOVER
;	PAGE 39

,		HALT ROUTINE
;
;		THIS ROUTINE EITHER HALTS ON ERROR OR ATTEMPTS
;		A RECOVERY OF THE SYSTEM FROM DRUM AND RESTART
;		OF JOSS FROM INITIAL CONDITIONS. APPROPRIATE ERROR
;		MESSAGE AND DUMPS ARE WRITTEN AT THE CONSOLE.
;		REGISTER 1 (B) HAS BEEN SAVED IN LOCATION 30.

R4:	FSW	B
	TRNN	B,HALTS;	SKIP IF HALTING
	JRST	R4.1
	HRR	B,40
	ADDI	B,777000
	HRRM	B,R4.99;	SIMULATE LOCAL HALT
	MOVE	B,30;		RECOVER REGISTER
R4.99:	JRST	4,777000

;	ATTEMPT RECOVERY FROM THE DRUM

R4.1:	CONO	PI,110000;	KILL PI SYSTEM AND PARITY FLAG
	CONO	APR,210000;	KILL PROCESSOR INTERRUPTS
	MOVE	B,[XWD YEAR,31]
	BLT	B,35;		SAVE DATE AND TIME
	MOVEM	C,42
	MOVEM	D,43
	MOVE	B,0(17)
	MOVEM	B,SA+2;		@17
	HRRZ	B,0
	MOVE	B,0(B)
	MOVEM	B,SA+3;		@0
	MOVE	B,-1(J)
	MOVEM	B,SA+1;		@J
	JRST	RJD;		GO TO READ DRUM

	SUBTTL	PROCESSOR INTERRUPT ROUTINES
;	PAGE 40

;		CHANNEL 7 INTERRUPTS

APRR:	Z
	CONSO	APR,1000;	IT IS THE CLOCK ISNT IT?
	JRST	CHECK;		PARITY, NOEX MEM, PDL OV
CLOCK:	AOS	TIME;		DUMP SYSTEM CLOCK
	SOSN	D.TIME;		TIME OUT THE DISC ROUTINES
	JSR	DISC.C;		TRY TO RECOVER DROPPED TRAP
	CONO	APR,1000+CAPR;	TURN OFF THE FLAG
	CONO	500,1;		PULSE THE "JOSS HERE" FLOP
	AOS	T.CU;		BUMP THE CURRENT USER CLOCK
	AOS	TICK;		INCREMENT TICKER
	AOS	SECONDS;	TICK COUNT (SOURCE OF TIMER)
	EXCH	B,TICK
	CAIGE	B,^D60;		SKIP IF ONE SECOND
	JRST	CL3
	MOVEM	C,CL9;		SAVE REGISTER
	AOS	B,SEC;		BUMP SECOND COUNT
	TRNE	B,3;		SKIP IF NOT 4 SEC BOUNDARY
	JRST	CL6;		GO TO BEEP SIGNALLED CONSOLES
CL8:	HRRZ	B,APRR;		FETCH INTERRUPT ADDRESS
	CAMN	B,CL12;		SKIP IF DIFFERENT THAN LAST TIME
	JRST	CL14
	HRRM	B,CL12;		SAVE LOC COUNTER
CL18:	SETZM	CL13;		ZERO COUNT
CL5:	FSW	B
	TRNE	B,BEEPS;	DO WE WANT TO BEEP
	JSR	C30;		GO MAKE NOISE
	TRNN	B,SDS;		SKIP IF SHUTTING DOWN
	JRST	CL4
	MOVE	B,SEC
	CAIG	B,^D5;		BEEP FOR 5 SEC EACH MIN
	JSR	C30

	SUBTTL	PROCESSOR INTERRUPT ROUTINES
;	PAGE 41

CL4:	MOVE	B,CT46;		INPUT INTERRUPTS
	IMULI	B,^D2000
	IDIV	B,USERS
	JSR	CVTL1
	AOS	IINT(C)
	MOVE	B,CT47;		OUTPUT INTERRUPTS
	IMULI	B,^D2000
	IDIV	B,USERS
	JSR	CVTL1
	AOS	OINT(C)
	MOVE	B,CT46
	ADD	B,CT47
	IMULI	B,^D2000
	IDIV	B,USERS
	JSR    CVTL1
	AOS	TINT(C)
	SETZM	CT46
	SETZM	CT47
	MOVE	C,CL9
	MOVEI	B,0;		ZERO THE TICKER
CL3:	EXCH	B,TICK
	EXCH	B,T.CU
	CAML	B,T.MAX
	JRST	CL2;		YES TIME IS UP
CL1:	EXCH	B,T.CU;		NO INTERRUPT YET
	JRST	12,@APRR

CL2:	SKIPN	SS99
	SKIPN	DMBY;		NOT MUCH POINT IF DRUM IS BUSY
	AOS	COMEBACK;	SET INTERRUPTER RETURN FLAG
	JRST	CL1

	SUBTTL	PROCESSOR INTERRUPT ROUTINES
;	PAGE 42

;	BEEP SIGNALLED CONSOLES EACH 4 SECONDS

CL6:	MOVE	B,CONSOL
	AOS	B;		START WITH FIRST JOSS CONSOLE
CL7:	CAIG	B,N.S*S.M;
	JRST	CL8;		FINISHED - ALL STATIONS TESTED
	SKIPN	TTT(B)
	AOJA	B,CL7;		NO SIGNAL - TRY NEXT
	LSHC	B,-1;		GET "TO" CONSOLE NUMBER
	JSR	C32;		BEEP THE CONSOLE
	LSHC	B,1
	AOJA	B,CL7;		CONTINUE SEARCH

;	DETECT INDIRECT ADDRESS LOOPS

CL14:	AOS	B,CL13;		COUNT INTERRUPT WITH THE SAME PC
	CAIG	B,^D10
	JRST	CL5;		NOT EXCESSIVE YET

;	TEN EVEN SECOND WITH THE SAME PC - TEST FOR ADDRESS LOOP

	MOVEM	D,CL10
	MOVEI	C,100
	MOVEM	C,CL11;		INDIRECT DEPTH COUNT
	MOVE	C,@APRR;	INITIAL WORD
CL15:	MOVE	D,C
	LDB	B,IRPTR;	GET INDEX REGISTER ADDRESS
	JUMPE	B,CL16;		JUMP IF NO INDEX
	CAIGE	B,4
	HRRZ	C,TICK-1(B);	GET STORED REGISTER
	CAIL	B,4
	HRRZ	C,(B)
	ADD	C,D;		ADDRESS PLUS IR CONTENTS
	CAIL	B,4
	MOVE	C,(C);		GET ADDRESSED WORD
	CAIGE	B,4
	MOVE	C,TICK-1(B);	IF SAVED
CL16:	TLNN	D,20;		SKIP IF INDIRECT BIT SET
	JRST	CL17;		END OF ADDRESS CHAIN
	SOSLE	CL11;		COUNT INDIRECT LEVELS
	JRST	CL15
H33:	HALT	33;		INDIRECT ADDRESS LOOP

CL17:	MOVE	D,CL10;		RESTORE REGISTER D
	JRST	CL18;		WASNT A LOOP

IRPTR:	POINT	4,C,17;		POINTER TO INDEX FIELD

	SUBTTL	CONSTANTS
;	PAGE 43

BLANKS:	ASCII	?     ?
	ASCII	?     ?
ZERO:	0
CRS:	OCT	064321506432;	FIVE CARRIAGE RETURNS
CRLF:	OCT	064240000000;	CR, LF, AND ZEROS
BELF:	ASCII	?
?

C3:	POINT	7,INITIAL
C4:	POINT	7,JOBNO
C5:	POINT	6,SWITCH,^D17;	POINTER TO DISPLAY LINE NUMBER
	SUBTTL	PROCESSOR ERROR RECOVERY
;	PAGE 44

;	TRY TO SAVE THE SYSTEM FROM HARDWARE ERRORS

;		NOTE THAT PROPER RECOVERY FROM MACHINE ERRORS
;		DEPENDS, IN PART, ON A SPECIFIC LOADING ORDER
;		FOR JOSS COMPONENTS.  IN PARTICULAR, THE ORDER
;		SHOULD BE: ARITH,DISTRIB, DISC, SU, CPU, DDT, IU.

CHECK:	CONSO	APR,10000;	SKIP IF NOEX MEM
	JRST	CHECK1
	HRRZ	J,APRR;		GET LOCATION OF ERROR
	CAIG	J,INTBEG
H27:	HALT	27;		NOT A REFERENCE FROM JOE
	CONO	APR,110007;	RESET FLAGS
	MOVEI	A,72
	JRST	10,KILL

CHECK1:	HRRZ	J,APRR;		PICK UP OFFENDING LOCATION
	CONSO	APR,20000;	SKIP IF CPA ILLEGAL OP
	JRST	CHECK2
	HRRZ	J,APRR
	CAIG	J,INTBEG
H31:	HALT	31;		MEMORY PROTECTION VIOLATION--NON-INTERPRETER
	CONO	APR,120007
	MOVE	A,74
	JRST	10,KILL

,	DISCARD A BAD USER BLOCK

KILL:	MOVE	PP,[XWD -N.PP1,PP1-1];	RESTORE MONITOR PUSH REGIS
	MOVE	S,CUI
	LDB	B,S.DU
	JUMPE	B,CHK1
	SETZM	DKBY;		DISABLE POSSIBLE DISC ACTION
	SKIPN	S,DQ
	JRST	CHK1
	AOS	DKBY;		ENABLE NEXT FOR DISC
	SUBI	S,S.Q
	CHS	COM.S
CHK1:	TSX	OGKM
	JRST	QUIT

;	HANDLE PARITY ERRORS

CHECK2:	CONSO	PI,100000;	SKIP IF PARITY ERROR
H2:	HALT	2;		PDL OVERFLOW
	CONO	PI,100000;	TURN OFF FLAG
	SKIPE	CU;		SKIP IF NO CURRENT USER
	JRST	CHK2
	AOS	CT15;		RECORD IN LOG
	XCT	KILL;		RESTORE PUSH REGISTER
	JRST	10,SIGPR;	GO TO MPL AND HOPE

CHK2:	MOVEI	A,76
	MOVEM	J,MINT(S);	DISPLAY OFFENDING LOCATION
	JRST	10,KILL;		DISCARD USER

	SUBTTL	OUTPUT A GRONK MESSAGE
;	PAGE 45

;	ON ENTRY REGISTER A CONTAINS THE GRONK CODE
;	A GRONK IS REPORTED AT THE CONSOLE TTY BY A LINE OF DATA
;	GIVING THE GRONK CODE (ONE OF THOSE LISTED BELOW), THE
;	NUMBER OF THE CONSOLE GRONKED, AND TWO DATA WORDS WITH
;	CONTENTS AS LISTED BELOW.

;	71- CKSUM FAILURE: 1) CORRECT, 2) INCORRECT
;		IF THE DP OR DR HARDWARE DETECTS AN ERROR THE
;		CONTENTS OF THE LEFT AND RIGHT HALVES OF
;		THE INCORRECT CHECKSUM WORD CONTAIN THE RESULTS
;		OF CONI INSTRUCTIONS ON THE DP AND DR.
;		  FAILURE TO COMPARE FINAL DATAI REGISTER CONTENTS
;		WITH COMPUTER VALUES ALSO TAKE THIS EXIT. IN THIS
;		CASE THE LEFT HALF WILL BE ZERO AND THE RIGHT
;		HALF WILL SHOW NO ERROR FLAG.
;	72- NOEX MEM FROM INTERPRETER
;	73- INITIALS CHECK: 1) BAD INITIALS, 2) GOOD
;	74- CPA ILL OP = PROTECT VIOLATION ON USER BLOCK REFERENCE
;	75- ILLEGAL UUO FROM INTERPRETER CODE
;	76- PARITY ERROR;	2) OFFENDING LOCATION

OGKM:	MOVE	S,CUI
	MOVE	J,A
	TSX	OFFNQ;		DO OFF PROCEDURE
	TSX	GETBUF
H26:	HALT	26;		IF SO WE ARE IN TERRIBLE TROUBLE
	MOVE	C,[POINT 7,1(E)]
	XMT 3,BELF
	CAILE	J,100;		SKIP IF A MONITOR CODE
	MOVE	J,0(J);		GET CONTENTS OF JWS PUSH LIST
	MOVE	A,J
	TSX	OCTW
	XMT 2,BLANKS
	MOVE	A,CUI
	TSX	OCT
	XMT 10,GKM
	XMT 2,BLANKS


;	PAGE 46

	MOVE	S,CUI
	MOVE	A,SUM(S)
	TSX	OCTW
	XMT 2,BLANKS
	MOVE	A,MINT(S);	POSSIBLE BAD CHECKSUM
	TSX	OCTW
	XMT 3,BELF
	XMT 3,CRLF
	HRREI	S,-1
	TSX	PUTB
	MOVE	S,CUI
	SETZM	MINT(S)
	AOS	CT21;		COUNT ERROR
	DONE

GKM:	ASCII	?\GRONK!\?;	8 CHARACTERS

	SUBTTL	CONVERT ROUTINES
;	PAGE 47

;	TABLE FOR CONVERSION TO LOGARITHMIC RANGE

CVTLOG:	DEC	500*60
	DEC	200*60
	DEC	100*60
	DEC	50*60
	DEC	20*60
	DEC	10*60
	DEC	5*60
	DEC	2*60
	DEC	1*60
CVTS=.-CVTLOG

,	CONVERT TO LOG RANGE

CVTL:	Z
	MOVEI	C,CVTS
	CAML	B,CVTLOG-1(C)
	SOJG	C,.-1
	JRST	2,@CVTL

,	TRAP TIME COPY OF CONVERT ROUTINE

CVTL1:	Z
	MOVEI	C,CVTS
	CAML	B,CVTLOG-1(C)
	SOJG	C,.-1
	JRST	2,@CVTL1

,	CONVERT A WORD TO OCTAL ASCII
,	  CLOBBERS D,B INPUT IS A.

OCTW:	MOVEI	D,^D12
	MOVE	B,A
OCTW1:	SETZM	A
	LSHC	A,3
	ORI    A,60
	IDPB	A,C
	SOJG	D,OCTW1
	DONE
	SUBTTL	MONITOR-INTERPRETER INTERFACE
;	PAGE 48

;	DECODE INTERPRETER SIGNALS

MONENT:	EXCH	S,CUI;		RESTORE THE USER INDEX
	MOVE	C,T.CU
	LDB	D,S.TM
	SUB	C,D;		TICKS SINCE LAST ENTRY
	ADDM	C,USTAT(S);	ACCUMULATE IN USER STATE BLOCK
	ADDM	C,COMTIM;	UPDATE USERS COMPUTE TIME
	ADDM	C,CT13;		UPDATE COMPUTE TIME THIS MINUTE
	ADDM	C,CT44;		ACCUMULATE TIME COMPUTING
	LDB	A,S.BLOCK;	NUMBER OF CORE BLOCKS
	IMUL	A,C
	ADDM	A,SPARE3;	INTEGRATE TIME X CORE SIZE="CHARGE UNITS"
	SETZB	A,T.CU
	DPB	A,S.INR;	RESET POSSIBLE IN SIGNAL
	ADD	C,D
	DPB	A,S.TM
	EXCH	PP,PPSAV;	RESTORE MONITOR PP REGISTER
	CALL	B,L.ETSW;	CHECK FOR WITHIN LIMIT.
H5:	HALT	5;		BAD SIGNAL FROM JOE
	JRST	@ENTSW(B);	INTERPRET ENTRY.

;	INTERPRETER SIGNAL TYPES

ENTSW:	JRST	SU;		0 - SWITCH TO USER
	JRST	BUFFER;		1 - GET A BUFFER
	JRST	REBUF;		2 - RETURN A BUFFER
	JRST	TL;		3 - TRANSMIT BUFFER TO USER
	JRST	TLSU;		4 - TRANSMIT AND SWITCH TO USER
	JRST	CONT;		5 - BREAK POINT RESPONSE
	JRST	DREQ;		6 - REQUEST DISC
	JRST	DCONT;		7 - CONTINUE DISC ACTION
	JRST	DCOMP;		8 - DISC ACTION COMPLETE
	JRST	MORCOR;		9 - GET ANOTHER BLOCK OF CORE
	JRST	MORCI;		10 - IMPERATIVE MORE CORE
	JRST	PAGE;		11 - MAKE UP AND SEND PAGE HEADING
	JRST	QUIT;		12 - GET USER OFF
	JRST	RCOR;		13 - RETURN BLOCKS OF CORE
	JRST	PAUSE;		14 - PAUSE FOR SIGNALS AND (E) SECONDS
	JRST	WAIT;		15 - PAUSE (E) SECONDS
L.ETSW=.-ENTSW+1;		LENGTH OF THE SWITCH
	Z;			SPARE

;	RETURN TO INTERPRETER

MONEXIT:MOVEI	G,INTENT;	INTERPRETER CONTEXT
MONE1:	EXCH	S,CUI
	EXCH	PP,PPSAV;	SAVE MONITOR PP REGISTER
	SETZM	COMEBACK
	JRST	@0(G);		GO TO PROPER INTERPRETER

	SUBTTL	INTERPRETER-MONITOR ENTRY ROUTINES
;	page 49

,	COMPUTATION BREAK

CONT:	CAMGE	C,T.MAX;	HAS HE HIT MAX?
	JRST	CONT1;		NO
	CHS	COM.S;		PUT CURRENT USER ON END OF LIST
	JRST	SIGPR1

CONT1:	AOS	CSS;		SET TOP OF QUEUE FOR CHS
	DPB	C,S.TM
	CHS	COM.S;		PUT ON TOP OF COMPUTE QUEUE
	SETZM	CSS;		RESET SWITCH
	JRST	SIGPR

,	TRANSMIT LINE TO USER

TL:	TSX	PUTB;		ATTACH BUFFER TO USER
	JRST	MONEXIT;	  GO BACK TO INTERPRETER
TLSU:	TSX	PUTB;		ATTACH BUFFER TO USER
	JRST	SU1

;	SWITCH CONSOLE TO USER

SU:	CAML	S,CONSOL;	SKIP IF TTY CONSOLE
	JRST	SU.5
	TSX	GETBUF
	JRST	SU3;		NO BUFFER--GO TO WAIT
	HRLZI	B,574000;	LEFT ARROW CHARACTER
	MOVEM	B,3(E);		STASH IN BUFFER
	TSX	PUTB;		TRANSMIT TO USER
SU.5:	HRRZ	E,S.BUF(S);	PICK UP BUFFER HEADER
	SETZM	RISIG;		RESET "IN" SIGNAL.
	JUMPE	E,SU2;		JUMP IF NO BUFFER ATTACHED.
SU1:	CHS	DSU.S;		PUT ON END ON DSU QUEUE.
	JRST	SIGPR1;		TO PROCESS SIGNALS.

SU2:	TSX	GETBUF
	JRST	SU3
	HRL	E,E
	MOVEM	E,S.BUF(S);	LINK BUFFER TO USER
	TSX	SG;		SWITCH GREEN
	JRST	SIGPR1

SU3:	CHS	ABG.S;		TO WAIT BUFFER FOR GREEN QUEUE.
	JRST	SIGPR


;	PAGE 50

;	WAIT FOR SIGNALS AND TIME

PAUSE:	MOVEI	B,1
	DPB	B,S.SIG

;	DELAY USER FOR (E) SECONDS

WAIT:	CHS	QP.S;		TO PAUSE STATE
	TSX	ISEC
	ADD	B,E
	CAILE	B,^D24*^D3600
	SUBI	B,^D24*^D3600
	SKIPE	E;		NO TIME SPECIFIED
	HRLM	B,S.Q(S);	SAVE WAKEUP TIME IN QUEUE WORD
	JRST	SIGPR


;	PAGE 51

;	GET A BUFFER

BUFFER:	MOVE	E,N.CK;		GET THE CHOKE NUMBER
	HRRZ	B,S.BUF(S);	GET TOP BUFFER LOCATION
	JUMPE	B,BU2;		OK - GET A BUFFER FOR HIM
	HRRZ	B,0(B);		GET NEXT ON LIST
	SOJG	E,.-2;		JUMP IF HE SHOULD NOT BE CHOKED
	CHS	CK.S;		HE HAS ENOUGH ALREADY--CHOKE UP
	JRST	SIGPR1

BU2:	TSX	GETBUF
	JRST	.+2;		NO BUFFER
	JRST	MONEXIT
BUF1:	CHS	UC.S;		PUT ON ABR-UC QUEUE
	JRST	SIGPR1

;	RETURN A BUFFER

REBUF:	TSX	MBA1;		PUT BUFFER ON AVAILABLE
	JRST	MONEXIT;	GO BACK TO INTERPRETER


;	PAGE 52

,	FINAL "OFF" FOR USER

QUIT:	LDB	C,S.BLOCK
	MOVE	D,[POINT 6,CT48A]
	ILDB	B,D
	SOJG	C,.-1
	SUBI	B,1
	DPB	B,D;		DECREMENT BLOCK SIZE DISPLAY
	SETZM	MINT(S)
	LDB	B,S.COR
	JUMPE	B,Q2;		NOT IN CORE--MUST BE A GRONK
	SUBI	B,BBLOCK;	COMPUTE PHYSICAL LOCATION
	LDB	C,S.BLOCK;	GET NUMBER OF BLOCKS
	SETZM	CORE(B);	RESET CORE MAP
	AOS	B
	SOJG	C,.-2;		FOR ALL ASSIGNED BLOCKS
	SOS	CT39;		DECREMENT # OF IN CORE USERS
Q2:	LDB	A,S.STA
	SETZM	S.S(S);		ZERO HIS STATUS
	DPB	A,S.STA;	EXCEPT STATE
	MOVEI	A,1
	DPB	A,S.BLOCK;	INITIAL BLOCK SIZE
	CHS	OF.S
	FSW D
	TRNN	D,OFFS;		DONT RE-ENABLE IF BLASTING OFF
	JSR	C31
	MOVE	D,[ASCII ?OFF-?];	DISPLAY OFFS ON CONSOLE TTY
	TSX	DOF
	JRST	SIGPR1


;	PAGE 53

;	SEND PAGE HEADING

;		OUTPUT PAGE HEADING LINE TO USER. ON INPUT  REGISTER E
;		CONTAINS A BUFFER ADDRESS

PAGE:	MOVE	C,[POINT 7,3(E)]; POINTER TO BUFFER BEGINNING
	SKIPL	E;		PAGED ALREADY!
	INS	14;		FORM FEED
	MOVE	A,HR
	TSX	CTDR;		CONVERT HOURS WITH LEADING BLANKS
	INS	":";		  INSERT A ":"
	MOVE	A,MIN
	TSX	CTD;		CONVERT MINUTES WITH LEADING ZEROS
	XMT 2,BLANKS
	XMT 12,DATE
	INS	"#"
	MOVE	A,S
	TSX	BTA;		CONVERT AND OUTPUT CONSOLE #
	XMT 2,BLANKS
	XMT 5,INITIALS
	XMT 5,JOBNO
	CAML	S,CONSOL;	SKIP IF TTY CONSOLE
	XMT 4,BLANKS;		CENTER PAGE NUMBER FOR JOSS CONSOLE
	AOS 	B,PAGNO;	FETCH AND INCREMENT PAGE NUMBER
	CAIGE	B,^D100;	CENTER PAGE NUMBER A LITTLE
	XMT 1,BLANKS
	INS	"["
	MOVE	A,PAGNO;	REMEMBER REG. A IS ZERO
	TSX	BTA;		CONVERT TO ASCII BASE TEN
	INS	"]"
	XMT 2,BLANKS
	TSX	HDM;		MAKE UP HEADING MESSAGE
	JRST	TL;		TRANSMIT THE LINE

	SUBTTL	MAKE UP PAGE HEADING MESSAGE
;	PAGE54

HDM:	FSW D;			FETCH DATA SWITCHES
	TRNE	D,PRMES;	SKIP IF NO PRIORITY MESSAGE
	JRST	PG4
	TRNN	D,SDS;		SKIP IF SHUTTING DOWN
	JRST	PG3
	XMT 34,HSDM; PUT SHUTDOWN MESSAGE IN HEADER
	JRST	PG1
PG3:	TRNN	D,DCLOB
	JRST	PG2
	XMT 30,DCLOBM;		SEND DISC CLOBBERED MESSAGE
	JRST	PG1
PG2:	TRNE	D,DAM;		SKIP IF NO DISPLAY
PG4:	SKIPN	D,L.OPM;	IS THERE A MESSAGE
	JRST	PG1;		NOTHING MORE FOR THIS LINE
	MOVE	D,[POINT 7,OPMSG]
	ILDB	A,D
	IDPB	A,C;		MOVE OPERATOR MESSAGE TO HEADING LINE
	SOJG	B,.-2
PG1:	XMT 6,CRS;  SIX CRS
	INS	0
	DONE

L.OPM:	DEC	0;		# CHARACTERS IN OPERATOR MESSAGE
OPMSG:	ASCII	/                              /; ONLY 30 CHAR

;	SHUTDOWN MESSAGE: "PREPARE FOR JOSS SHUTDOWN.".
HSDM:	BYTE	(7)  120,162,145,160,141,162,145,40,146,157
	BYTE	(7)  162,7,40,112,117,123,123,40,163,150
	BYTE	(7)  165,164,144,157,167,156,56,7

,	DISC CLOBBERED MESSAGE: "FILES ARE NOT USEABLE."
DCLOBM:	BYTE	(7)  7,106,151,154,145,163,40,141,162,145
	BYTE	(7)  40,7,156,157,164,40,165,163,7,141
	BYTE	(7)  142,154,145,56
	SUBTTL	DISC ENTRY ROUTINES
;	PAGE 55

;	DISC ACTION ROUTINES

DREQ:	MOVEI	A,1
	SETZM	SPARE4;		RESET DISC AVAILABLE FLAG
	DPB	A,S.DU;		FLAG AS DISC USER
	SKIPN	DKBY;		SKIP IF DISC IS BUST
	JRST	DREQ1
	CHS	DQ.S;		DISC BUSY - PUT ON QUEUE
	JRST	SIGPR1
DREQ1:	AOS	DKBY;		SET DISC BUSY SWITCH
	SETOM	SPARE4;		TELL JOE HE GOT THE DISC
	JRST	MONEXIT;	RETURN TO INTERPRETER


DCONT:	CONSO	PI,CHDC
	JRST	DCONT1;		JUMP IF DC IDLE
	CHS	DCT.S;		WAIT FOR DC TO IDLE
	JRST	SIGPR1
DCONT1:	CHS	DIP.S;		DISC IN PROGRESS QUEUE
	JSR	DISC.C;		CONTINUE TO DISC ACTION
	JRST	SIGPR1

DCOMP:	SETZB	B,DKBY;		INDICATE DISC IDLE
	DPB	B,S.DU;		RESET DISC FLAG
	EXCH	S,MISC
	SKIPN	S,DQ;		SKIP IF SOMEONE IN THE QUEUE
	JRST	DCP1;		NONE IN QUEUE
	AOS	DKBY;		BUST THE DISC
	SUBI	S,S.Q;
	CHS	COM.S;		ACTIVATE USER
DCP1:	EXCH	S,MISC
	LDB	A,S.OFR;	GET OFF FLAG
	JUMPE	A,MONEXIT;	RETURN TO INTERPRETER
	TSX	OFFNQ;		DO OFF PROCESSING
	JRST	SIGPR1

;	DISC RESTART ROUTINE

DSTRT:	CONSZ	PI,CHDC
	DONE;			NO RESTART IF DC IS BUSY
	SUBI	S,S.Q
	CHS	DIP.S
	JSR	DISC.C;		CONTINUE DISC ACTION
	DONE

	SUBTTL	PRODUCE DISC ACCOUNTING RECORD
;	PAGE 56

;	ACCOUNT FOR DISC USAGE AT DISCARD TIME
;	USES REGISTERS B,E,S; ENTERED VIA PUSHJ PP,ADIS.

ADIS:	MOVEI	C,1
	MOVS	B,DISC.D(C)
	CAMN	B,DISC.D(C);	SKIP IF DATES ARE DIFFERENT
	DONE;			NO ACCOUNTING
	TSX	GETBUF
	DONE;			IN THIS CASE THEY GO FREE
	MOVE	B,FILE
	MOVEM	B,^D7(E)
	MOVE	B,KEY
	MOVEM	B,^D8(E)
	MOVE	B,MINT(S)
	MOVEM	B,^D9(E)
	MOVE	B,[XWD ^D9,^D9]
	MOVEM	B,1(E)
	MOVEI	B,2(E);		TO ADDRESS
	HRLI	B,DISC.D;	ADDRESS OF ACCOUNTING DATA
	MOVE	S,B
	BLT	B,4(S);		MOVE TO BUFFER
	HRRZ	B,PROG
	HRRM	B,2(E)
	MOVE	A,6(E)
	TLNE	A,777777;	CHECK FOR BINARY
	TSX	TLT;		NO - CONVERT FROM ASCII
	TLNE	A,777777
	MOVEM	F,6(E)
	MOVE	S,[DEC -2];	CONTEXT FOR TAPE
	TSX	PUTB
	DONE

TLT:	SETZM	F
	MOVE	C,[POINT 7,A]
TLT1:	ILDB	D,C
	CAIN	D," ";		WE ARE DONE ON THE FIRST BLANK
	DONE
	ANDI	D,17
	IMULI	F,^D10
	ADD	F,D
	JRST	TLT1

	SUBTTL	CONVERSION ROUTINE - BINARY TO BASE TEN ASCII
;	PAGE 57

;		THE NUMBER IN A IS CONVERTED AND STUFFED IN THE STRING
;		AT C, B IS CLOBBERED

BTA:	SETZM	B
	IDIVI	A,^D10
	HRLM	B,0(PP);	PUT REMAINDER AWAY ON PDL
	JUMPE	A,BTA1;		END, GO TO OUTPUT
	TSX	BTA;		RECURSE

BTA1:	HLRZ	A,0(PP);	RECOVER DIGIT
	ORI	A,60;		PUT IN THE ASCII BITS
	IDPB	A,C;		DEPOSIT IN STRING
	DONE

	SUBTTL	RETURN BLOCKS OF CORE
;	PAGE 58

RCOR:	LDB	C,S.BLOCK
	MOVE	D,[POINT 6,CT48A]
	ILDB	A,D
	SOJG	C,.-1
	SUBI	A,1;		DECREMENT SIZE DISTRIBUTION
	DPB	A,D
	LDB	C,S.BLOCK
	SUB	C,E
	CAIGE	C,1
H23:	HALT	23;		ATTEMPT TO RETURN ALL USER CORE
	DPB	C,S.BLOCK;	SET NEW USER SIZE
	MOVE	D,[POINT 6,CT48A]
	ILDB	A,D
	SOJG	C,.-1
	ADDI	A,1
	DPB	A,D;		INCREMENT SIZE DISTRIBUTION
	LDB	C,S.BLOCK
	LDB	A,S.COR
	SUBI	A,BBLOCK
	ADD	C,A
	ADD	C,E;		LOCATION OF BLOCKS TO BE RELEASED
	SUBI	C,1
	SETZM	CORE(C);	ZERO THE FREED BLOCKS
	SOJG	E,.-2
	TSX	SRR;		RESET PROTECT
	JRST	MONEXIT
	SUBTTL	PROVIDE MORE CORE FOR USERS BLOCK
;	PAGE 59

MORCOR:	MOVEI	B,0;		PRESET TO DENY REQUEST
	LDB	C,S.BLOCK;	CURRENT # OF BLOCKS
	CAML	C,N.CB;		COMPARE WITH MAX ALLOWABLE
	JRST	MONEXIT;	ENOUGH - DENY REQUEST
MORC1:	MOVE	D,[POINT 6,CT48A]
	ILDB	B,D
	SOJG	C,.-1;		COUNT DOWN TO PROPER BYTE
	SUBI	B,1
	DPB	B,D;		ONE LESS AT THIS SIZE
	ILDB	B,D
	ADDI	B,1
	DPB	B,D;		ONE MORE AT NEXT SIZE

,	IS BLOCK JUST ABOVE HIM FREE?

	LDB	C,S.BLOCK;	CURRENT # OF BLOCKS
	LDB	D,S.COR;	CURRENT BLOCK LOCATION
	SUBI	D,BBLOCK
	ADD	D,C;		INDEX TO NEXT HIGHER BLOCK
	AOS	C;		NUMBER OF REQUIRED BLOCKS
	CAML	D,N.C;		SKIP IF NOT TOP USER
	JRST	MOR6;		TO MOR1 FOR INCREASE IN CORE *******
	SKIPE	B,CORE(D);	SKIP IF BLOCK IDLE
	JRST	MOR6;		TO MOR1 TO INCREASE IN CORE************
	TLO	B,400000;	SET IN USE
	MOVEM	B,CORE(D)
	DPB	C,S.BLOCK;	NOW HE HAS ONE MORE

M1:	MOVEI	B,1;		TELL JOE HE GOT ONE
	TSX	SRR
	JRST	MONEXIT;	TELL INTERPRETER HE GOT ONE.

;	IMPERATIVE REQUEST FOR MORE CORE

MORCI:	LDB	C,S.BLOCK
	CAMGE	C,N.C;		SKIP IF TOO BIG FOR MACHINE
	JRST	MORC1
	MOVEI	B,0
	JRST	MONEXIT;	DENY REQUEST

,	NOW WE MUST SET UP A SWAP

MOR6:	DPB	C,S.BLOCK;	SET NEW SIZE
	SKIPN	DMBY;		SKIP IF DRUM IS BUSY
	JRST	MOR7
	CHS	QDM.S;		PUT ON QUEUE FOR OUT
	JRST	SIGPR

MOR7:	SUBI	C,1;		SIZE TO SHIP OUT
	SETOM	DMIN;		INDICATE NO USER IN
	TSX	OSWAP;		START HIM OUT
	CHS	QC.S;		PUT ON QUEUE TO COME BACK
	JRST	SIGPR


;	PAGE 60

;	FIND A FREE BLOCK OF CORE
;	  (OF REQUIRED SIZE ANYWHERE)

,	C- REQUIRED # OF BLOCKS, E IS DESTROYED
,	B= INDEX OF TOP FOUND BLOCK, D= CORE CELL (=0) OF LAST BLOCK
;	ROUTINE SKIPS ON NO SUCCESS

FINDB:	MOVEI	B,0
MOR2:	MOVEI	E,0
MOR2.5:	SKIPE	D,CORE(B)
	JRST	MOR3.5
	AOS	E
	CAMG	C,E;		IS BLOCK OF REQUIRED SIZE?
	DONE;			YES, TAKE SUCCESS EXIT
MOR3:	AOS	B
	CAMGE	C,N.C;		SKIP IF SEARCHED ALL BLOCKS
	JRST	MOR2.5
	AOS	0(PP);		BUMP TO NO SUCCESS EXIT
	DONE
MOR3.5:	MOVEI	E,0
	JRST	MOR3

ZZ=.


;	PAGE 61

;	FIND A FREE BLOCK OF THE REQUIRED SIZE
;	  (C = REQUIRED SIZE)

MOR1:	TSX	FINDB
	JRST	M2;		FOUND GO TO MOVE

,	FIND A FREE BLOCK BELOW USER

,	EXITS WITH B= INDEX TO FREE BLOCK

MOR4:	LDB	B,S.COR
	SUBI	B,BBLOCK
	JUMPE	B,MOR5;		JUMP IF NO BLOCKS BELOW
	SUBI	B,1
MOR41:	MOVE	D,CORE(B)
	TLNE	D,200000;	SKIP IF DRUM NOT USING BLOCK
	JRST	MOR5;		DRUM USING THIS AREA -- CANT TAMPER
	SKIPN	D
	JRST	M4;		FOUND ONE: GO TO MOVE
	SOJGE	B,MOR41;	GO FOR NEXT BLOCK


;	PAGE 62

,	FIND A FREE BLOCK ABOVE USER; C= # OF REQUIRED BLOCKS

MOR5:	LDB	B,S.COR
	SUBI	B,BBLOCK
	ADD	B,C;		START LOOKING ABOVE
	SUBI	B,2
MOR51:	CAML	B,N.C
	JRST	MOR6;		NONE , TRY SWAPS
	MOVE	D,CORE(B)
	TLNE	D,200000
	JRST	MOR6;		DRUM IS USING CORE
	SKIPN	D
	JRST	M5;		FOUND ONE: GO TO MOVE
	AOJA	B,MOR51;	GO TO LOOK AT NEXT BLOCK


;	PAGE 63

;	MOVE USER TO FREE AREA

,	C= # OF BLOCKS IN NEW USER AREA
,	B= CORE MAP INDEX OF LAST BLOCK IN "TO" REGION

M2:	TLO	D,400000;	BUSY THE HIGH BLOCK
	MOVEM	D,CORE(B)
	DPB	C,S.BLOCK;	NEW NUMBER OF BLOCKS
	SUBI	C,1;		BLOCKS TO MOVE
	SUB	B,C;		"TO" BLOCK LOCATION
	LDB	E,S.COR
	SUBI	E,BBLOCK;	INDEX OF "FROM" BLOCK
	MOVE	G,E;		SAVE "FROM" LOCATION
	TSX	BLTC;		MOVE USER AND CORE MAP
M25:	SETZM	CORE(G);	ZERO OLD MAP
	AOS	G
	SOJG	C,M25
	TSX	RUL;		RESET USER LOCATIONS
	JRST	M1;		SUCCESS RETURN TO JOE

;	MOVE DOWN MULTIPLE USERS (B=FREE BLOCK INDEX)

,	C= NEW SIZE

M4:	LDB	F,S.COR
	SUBI	F,BBLOCK
	DPB	C,S.BLOCK;	NEW SIZE
	ADD	C,F
	MOVE	A,C;		SAVE INDEX OF HIGH BLOCK
	SUBI	C,2
	SUB	C,B;		BLOCKS TO MOVE
	MOVE	E,B;		"TO" LOCATION
	ADDI	E,1;		"FROM" LOCATION
	TSX	BLTC;		MOVE USER
	TSX	RUL;		RESET LOCATION FOR AFFECTED USERS
	MOVEI	B,1
	EXCH	A,B
	DPB	A,S.IU;		BUSY THE FREED BLOCK
	JRST	M1;		BACK TO JOE


;	PAGE 64

,	MOVE USER(S) UP

,	B= FREE BLOCK INDEX, C= NEW SIZE

M5:	DPB	C,S.BLOCK;	SET NEW SIZE
	LDB	E,S.COR
	SUBI	E,BBLOCK
	ADD	E,C
	SUBI	E,1
	PUSH	PP,B;		SAVE FREE BLOCK LOCATION
M51:	MOVE	A,CORE-1(B)
	MOVEM	A,CORE(B);	MOVE THE CORE MAP
	SOS	B
	CAMLE	B,E
	JRST	M51
	MOVEI	C,1
	DPB	C,S.IU;		BUSY THE NEW BLOCK
	POP	PP,B
	ADDI	B,BBLOCK
	ASH	B,^D10
	ADDI	E,BBLOCK
	ASH	E,^D10;		LAST WORD TO BE MOVED
M52:	SOS	B
	MOVE	D,0(B)
	MOVEM	D,2000(B)
	CAMLE	B,E
	JRST	M52
	TSX	RUL;		RESET USER LOCATIONS
	JRST	M1;		RETURN TO JOE

RELOC	ZZ


;	PAGE 65

;	RESET USER LOCATIONS

,	SCAN CORE MAP AND UPDATE USER LOCATIONS

RUL:	EXCH	S,MISC
	MOVEI	B,0
RUL1:	SKIPN	E,CORE(B);	SKIP IF BUSY BLOCK
	AOJA	B,RUL2;		BUMP TO NEXT
	TLNE	E,200000
	AOJA	B,RUL2;		DONT MESS WITH DRUM CORE
	LDB	S,S.UR;		USER FOR THIS BLOCK
	MOVE	E,B
	ADDI	E,BBLOCK
	DPB	E,S.COR
	LDB	E,S.BLOCK
	LDB	F,S.STA
	CAIN	F,QDM.S
	SUBI	E,1
	ADD	B,E;		BUMP PAST THIS USER
RUL2:	CAMGE	B,N.C
	JRST	RUL1;		AROUND FOR NEXT
	EXCH	S,MISC
	DONE


;	PAGE 66

;	BLOCK TRANSFER CORE

,	MOVE BLOCKS DOWN - USERS AND CORE MAP
,		C= BLOCKS TO BE MOVED
,		B= "TO" BLOCK INDEX
,		E= "FROM" BLOCK INDEX
,	CLOBBERS F,E,B.

BLTC:	HRL	B,E;		BLT POINTER WORD
	MOVE	E,B
	ADD	E,C
	SUBI	E,1
	MOVE	F,B;		F MAY BE DESTROYED BY INTERRUPT
	ADD	F,[XWD CORE,CORE]
	BLT	F,CORE(E);	MOVE CORE MAP
	ADD	B,[XWD BBLOCK,BBLOCK]
	ASH	E,^D10
	ADDI	E,BBLOCK
	ASH	E,^D10
	BLT	D,2000-1(E)
	DONE

,	SET RELOCATION REGISTER

SRR:	LDB	D,S.COR
	ASH	D,^D10
	ADD	D,[OCT 100000700000];
	LDB	I,S.BLOCK
	SUBI	I,1
	ASH	I,^D10
	MOVSS	I
	ADD	D,I
	DATAO	APR,D;		SET RELOCATION
	DONE
; PG 67

,	COMPACT CORE

COMPACT:SETZB	B,H
	SKIPN	CORE(B)
	AOS	H;		COUNT FREE BLOCKS IN H
	AOS	B
	CAMGE	B,N.C
	JRST	.-4
	TSX	COMP1;		DO A SINGLE COMPACT
	DONE
	JRST	.-2

;	DO ONE COMPACT

COMP1:	TSX	FM;		FIND A MOVE
	DONE;			NONE
	MOVE	D,C
	ADD	D,B;		BEGINNING OF FREED AREA
	TSX	BLTC;		DO THE MOVE
COMP2:	SETZM	CORE(D);	ZERO FREED CORE
	AOS	D
	CAMGE	D,G
	JRST	COMP2
	MOVE	E,C
	ADDM	C,CT50
	ADDM	E,T7+5
	TSX	RUL;		RESET USER LOCATIONS
	AOS	0(PP)
	DONE;			TAKE "DID ONE" EXIT

; PG 68

;	FIND A CORE MOVE

,	EXISTS +1 IF NONE, +2 IF A MOVE IS FOUND
;	ON ENTRY H= # OF FREE BLOCKS
;	ON EXIT:
;		B= 1ST FREE LOCATION ("TO" BLOCK)
;		E= 1ST NON-ZERO BLOCK ("FROM" BLOCK)
;		C= # OF BLOCKS TO MOVE
;		G= # OF FIRST UNAFFECTED BLOCK
;	F AND I ARE CLOBBERED

FM:	MOVEI	B,0
FM1:	MOVE	D,CORE(B)
	JUMPE	D,FM2;		SEARCH FOR 1ST UNUSED BLOCK
	AOS	B
	CAME	B,N.C;		END TEST
	JRST	FM1
	DONE;			EXIT: NO FREE BLOCKS IN CORE

FM2:	MOVE	E,B;		B IS "TO" LOCATION (1ST FREE BLOCK)
	MOVE	I,H
FM3:	SKIPE	CORE(E);	SEARCH FOR 1ST NON-ZERO BLOCK
	JRST	FM4
	AOS	E
	SOSG	I
	DONE;			WE HAVE ALL FREE BLOCKS TOGETHER
	CAME	E,N.C;		END TEST
	JRST	FM3
	DONE;			CORE IS ALREADY COMPACT

FM4:	MOVE	C,E;		E IS "FROM" LOCATION (1ST NON-ZERO)
FM5:	MOVE	F,CORE(C)
	JUMPE	F,FM7
	TLNE	F,200000;	SKIP IF DRUM NOT USING BLOCK
	JRST	FM7;		DO NOT MOVE DRUM CORE
	AOS	C
	CAME	C,N.C;		END TEST
	JRST	FM5

FM7:	MOVE	G,C;		SAVE # OF FIRST UNAFFECTED BLOCK
	SUB	C,E;		C HAS # OF BLOCKS TO MOVE
	SKIPG	C
	DONE;			NO NEED TO MOVE ZERO BLOCKS
	AOS	0(PP);		TO SECOND EXIT--MOVE FOUND
	DONE

; PG 69

,	FIND A USER TO BRING IN

SELSWP:	SKIPN	ON
	SKIPE	N.DRM
	JRST	.+2;		SELECT FOR SWAP IF "ON" USERS OR SOME ON DRUM
	DONE
	MOVE	C,[POINT 5,SI1];  TABLE OF CANDIDATES
SS1:	ILDB	B,C
	CAIN	B,END.S
	DONE;			NONE REQUIRED
	MOVEI	A,1
	HRRZ	B,S.QUE(B);	QUEUE HEADER
	JUMPE	B,SS1;		JUMP IF LIST EMPTY
SS2:	HRRZ	S,B
	SUBI	S,S.Q;		STATION INDEX
	LDB	D,S.COR;	GET CORE LOCATION
	LDB	F,S.GK
	JUMPN	F,SS3;		DONT BRING IN A GRONKED USER
	LDB	F,S.STA;	AND STATE
	CAIN	F,ON.S
	JRST	SS10;		DEAL WITH "ON" SEPARATELY
	JUMPE	D,SS4;		JUMP IF NOT IN CORE
SS3:	HRRZ	B,0(B);		GET NEXT ON LIST
	JUMPE	B,SS1;		JUMP TO GET NEXT LIST
	AOJA	A,SS2

,	USER # IN S, STATE IN F, PLACE IN QUEUE IN A

,	FIND A FREE BLOCK FOR HIM

SS4:	HRRZM	S,DMIN;		SET "IN" CANDIDATE
	HRLM	A,DMIN;		SET PLACE IN QUEUE
SS5:	LDB	C,S.BLOCK;	GET SIZE
	TSX	FINDB;		FIND A FREE BLOCK OF THE RIGHT SIZE
	JRST	SS15;		FOUND, GO TO START IN

,	TRY TO FIND SCATTERED FREE BLOCKS

	SETZB	B,E
SS6:	SKIPN	CORE(B)
	AOS	E;		COUNT FREE BLOCKS
	AOS	B
	CAMGE	B,N.C
	JRST	SS6
	CAMGE	E,C;		SKIP IF ENOUGH FREE TO COMPACT
	JRST	SS17;		CANT COMPACT
	TSX	COMPACT;	COMPACT CORE
	LDB	C,S.BLOCK
	TSX	FINDB
	JRST	SS15;		FOUND
	JRST	SS17;		STILL CANT FIND--TRY SOMETHING ELSE

; PG 70

,	DEAL WITH "ON" SEPARATELY

SS10:	MOVE	B,N.C
	SUBI	B,1
	SKIPN	CORE(B)
	DONE;			WE HAVE A FREE BLOCK. SELINT WILL FIND
	SOJGE	B,.-2;		SEARCH CORE FOR A FREE BLOCK
	MOVE	B,[POINT 5,S12];  89SEARCH LIST
	MOVE	H,[TSX SS18];	TEST ROUTINE
	TSX	FIND
	DONE;			CANT FIND ONE BEST GET COMPUTING
	HRROM	S,DMIN;		SET NO IN REQUIRED
SS11:	LDB	C,S.BLOCK
	TSX	OSWAP
	DONE

,	READY FOR "IN" SWAP; B= TOP OF IN BLOCK

SS15:	LDB	C,S.BLOCK
	SUBI	C,1
	SUB	B,C
	MOVEM	B,DMIBK;	SET "IN" BLOCK LOCATION
	TSX	ISWAP
	DONE

,	FIND A LOW PRIORITY USER OF THE PROPER SIZE

SS17:	MOVE	F,C
	MOVE	B,[POINT 5,S11]
	MOVE	H,[TSX SS18]
	TSX	FIND
	JRST	SS30;		CANT FIND A SINGLE - TRY MULTIPLE
	JRST	SS11;		FOUND - GO TO START OUT

SS18:	LDB	G,S.COR
	SKIPN	G;		SKIP IF IN CORE
	DONE
	CAMGE	D,G;		SKIP IF BIG ENOUGH
	DONE
	AOS	0(PP);		BUMP TO SUCCESS EXIT
	DONE

; PG 71

;	FIND CANDIDATE(S) FOR DRUM
S10:	BYTE	(5) QP.S,ABG.S,DSU.S,GR.S,DQ.S,CK.S,DIP.S,DCT.S,END.S

S11:	BYTE	(5) QP.S,ABG.S,DSU.S,GR.S,END.S
S12:BYTE (5) QP.S,ABG.S,DSU.S,GR.S,DQ.S,CK.S,DIP.S,DCT.S,COM.S,END.S


,	FIND MULTIPLE USERS TO KICK OUT
,	E= # OF FREE BLOCKS, F= REQUIRED SIZE TO FREE

SS30:	MOVE	B,[POINT 5,S10]
	MOVE	H,[TSX SS35];	TEST ROUTINE
	MOVE	G,DMNR
	SUB	F,E;		REQUIRED BLOCKS TO FREE
	TSX	FIND
	JRST	SS40;		NO SUCCESS - TRY COMPUTE QUEUE

,	START OUT, POSSIBLY MULTIPLE, USERS

SS32:	POP	G,S;		GET FIRST USER TO WRITE
	LDB	C,S.BLOCK
	TSX	OSWAP;		START HIM TO DRUM
	MOVEM	G,DMNR;		SAVE LIST OF USERS TO WRITE
	TLNE	G,777777;	SKIP IF ONLY ONE TO WRITE
	JRST	SS33
	LDB	B,S.BLOCK;	BLOCKS WRITTEN
	HRRZ	S,DMIN;		USER TO COME IN
	LDB	C,S.BLOCK;	BLOCKS TO COME IN
	CAMGE	B,C;		SKIP IF WE ARE FREEING ENOUGH SPACE
	AOS	SS98;		FIRE COMPACT ACTION
	DONE;			DONE WITH SWAP SELECTION

SS33:	MOVEI	C,1
	AOS	SS98;		SIGNAL CORE COMPACT NEEDED
SS34:	POP	G,S
	LDB	D,S.BLOCK
	LDB	B,S.COR
	SUBI	B,BBLOCK
	DPB	C,S.ID;		BUSY ALL BLOCKS INVOLVED IN SWAP
	AOS	B
	SOJG	D,.-2
	TLNE	G,777777
	JRST	SS34
	DONE

SS35:	LDB	A,S.COR
	SKIPN	A
	DONE;			NOT IN CORE TRY NEXT
	SUB	F,D
	PUSH	G,S;		SAVE AS USER TO WRITE
	SKIPLE	F;		SKIP IF WE HAVE SELECTED ENOUGH
	DONE
	AOS	0(PP)
	DONE;			TAKE SUCCESS EXIT

; PG 72

,	NOW WE MUST KICK OUT A COMPUTE USER
,	F= REQUIRED BLOCKS TO FREE, DMIN: R=USER FOR IN,L= PLACE IN QUEUE
,	G= CURRENT LIST TO WRITE
,	E= # OF FREE BLOCKS

SS40:	MOVE	S,DMIN
	LDB	B,S.STA;	GET STATE OF GUY COMING IN
	MOVEI	D,1
	MOVEI	A,1
	CAIN	B,COM.S;	SKIP IF "IN" USER NOT ON COM QUEUE
	HLRZ	A,S;		GET "INS" PLACE IN QUEUE
	MOVE	C,COM;		GET COMPUTE QUEUE HEADER
	JUMPE	C,SS45;		NONE IN COMPUTE - BEST GET TO COMPUTING
	MOVEI	B,END.S
	PUSH	PP,B;		PUT A FLAG ON THE LIST
SS41:	HRRZ	S,C
	SUBI	S,S.Q
	PUSH	PP,S;		UNRAVEL COM LIST TO SEARCH BACKWARD
	AOS	D
	HRLM	D,0(PP);	RECORD PLACE IN QUEUE
	HRRZ	C,0(C)
	JUMPN	C,SS41;		JUMP IF NOT LAST ON QUEUE
SS42:	POP	PP,S;		GET USER FROM INVERTED QUEUE
	CAIN	S,END.S
	JRST	SS45;		END OF QUEUE
	HLRZ	D,S;		PLACE IN QUEUE
	CAMG	D,A
	JRST	SS44;		CANT FIND USER OF LOW ENOUGH PRIORITY
	LDB	B,S.COR
	JUMPE	B,SS42;		JUMP IF OUT OF CORE
	SUB	F,B;		FOUND ONE, DECREMENT REQUIRED SIZE
	PUSH	G,S;		PUT ON WRITE LIST
	JUMPG	F,SS42;		GO FOR MORE IF NEEDED
	POP	PP,B
	CAIE	B,END.S
	JRST	.-2
	AOS	T7+6;		COUNT COMPUTE USERS KICKED OUT
	JRST	SS32;		SUCCESS--GO FOR FIRST WRITE

SS44:	POP	PP,B
	CAIE	B,END.S
	JRST	.-2

SS45:	MOVE	B,[XWD 0,DMNR]
	MOVEM	D,DMNR;		RESET WRITE QUEUE HEADER
	DONE;			CANNOT SET UP WRITE--NEED TO COMPUTER
	
TEST:	MOVEI	S,N.S-1
TE1:	LDB	B,S.COR
	JUMPE	B,TE2;		JUMP IF NOT IN CORE
	ASH	B,^D10
	MOVE	B,2(B);		INITIALS FROM USERS BLOCK
	CAME	B,MINT(S)
H22:	HALT	22;		NOT THE SAME AS CORE RECORD
TE2:	SOJGE	S,TE1
	DONE

; PG 73

,	COMPACT CORE FOR SWAP IN

SS90:	TSX	TEST
	TSX	COMPACT;	COMPACT CORE
	TSX	TEST
	MOVE	S,DMIN
	SETZM	SS99;		RESET COMPACT SWITCH
	LDB	C,S.BLOCK
	TSX	FINDB
	JRST	SS15
	SETZM	DMBY
	DONE;			NOT ROOM ENOUGH - MORECORE MUST HAVE STOLEN ONE

SS98:	Z;	SET IF MULTI WRITE
SS99:	Z;	SET TO REQUEST COMPACTION OF CORE AND IN SWAP

; PG 74

,	FIND FIRST USER IN STATES LISTED AT POINTER IN B
;	WHICH SATISFIES TEST IN H (THAT SKIPS ON SUCCESS).

,	C IS DESTROYED, S IS SET TO FOUND USER

FIND:	ILDB	C,B;		INDEX TO STATE HEADER
	CAIE	C,END.S;	SKIP IF END
	JRST	F1
	DONE;			FAILURE EXIT

F1:	HRRZ	C,S.QUE(C);	LIST HEADER
	JUMPE	C,FIND;		JUMP IF LIST EMPTY
F2:	HRRZ	S,C
	SUBI	S,S.Q;		COMPUTE STATION INDEX
	LDB	D,S.BLOCK
	XCT	H;		DO TEST
	JRST	F3
	AOS	0(PP)
	DONE;			TEST SUCCEEDS

F3:	HRRZ	C,0(C);		TEST ROUTINE FAILS; GET NEXT ON LIST
	JUMPN	C,F2;		JUMP IF AN ENTRY
	JRST	FIND;		GO FOR NEXT LIST
SUBTTL MISCELLANEOUS MPL FUNCTIONS

;	FORCE USERS OFF

BOFF:	SETZM	N.SON;		ALLOW NO MORE ON
	MOVEI	A,SDS+DOAF;
	ORM	A,SWITCH;	SET SHUTDOWN AND OFF SIGNAL DISPLAY
	HRLI	A,3;		GET AN OFF SIGNAL
	CONO	PI,1000+CH630;	TURN OFF 630 INTERRUPT
	MOVE	C,SG.L;		SIGNAL TABLE SIZE
	MOVEI	S,N.S-1;	STATION # FROM TOP DOWN
BOF1:	LDB	B,S.STA;	GET STATE
	LDB	F,S.DU;		GET DISK USE FLAG
	JUMPN	F,BOF5;		DONT KICK DISC USER
	MOVE	F,[POINT 5,BOF10]
BOF2:	ILDB	E,F;		GET EXEMPT STATE
	CAIN	E,END.S;	SEARCHED ALL EXEMPTS?
	JRST	BOF3;		YES, NOT EXEMPT
	CAMN	E,B;
	JRST	BOF5;		EXEMPT STATE- NO OFF SIGNAL
	JRST	BOF2;		GO FOR NEXT
BOF3:	HRR	A,S;		MAKE UP SIGNAL
	MOVEM	A,SIGTBL(C);	PUT ON SIGNAL LIST
	AOS	C;		COUNT LIST
BOF5:	SOJGE	S,BOF1;		GO FOR NEXT
	MOVEM	C,SG.L;		NUMBER OF ENTRIES
	CONO	PI,2000+CH630;	TURN ON 630 INTERRUPTS
	DONE

,	LIST OF STATES WHICH SHOULD NOT BE SUMMARILY KICKED OFF

BOF10:	BYTE (G) OF.S,TOF.S,END.S

;	PROCESS USERS WAITING FOR BUFFERS

MSGPR:	SUBI	S,S.Q;		COMPUTE USER NUMBER
	TSX	GETBUF
	DONE;			SHOULDNT HAPPEN THE FIRST TIME
	CAML	S,CONSOL;	SKIP IF TTY CONSOLE
	JRST	MSGPR1
	HRLZI	B,574000;	LET ARROW CODE
	MOVEM	B,3(C);		STASH IN BUFFER
	TSX	PUTB
	CHS	DSU.S
	DONE
MSGPR1: HRL	E,E
	MOVEM	E,S.BUF(S);	LINK TO USER
	TSX	SG;		SWITCH TO GREEN
	DONE

,	PROCESS THE PAUSE QUEUE

PQP:	HLR	C,0(S);		GET TIME COUNT
	JUMPE	C,PQP2
	HRR	S,0(S);		NEXT ON LIST
	TSX	ISEC
	CAIE	B,C
	JRST	PQP2;		TIME NOT UP YET
	CHS	COM.S;		ITS TIME - ACTIVATE HIM
	HRRZS	S.Q(S);		ZERO REQUEST TIME
PQP2:	JUMPN	S,PQP;		JUMP IF MORE IN PAUSE QUEUE
	DONE

;	PROCESS DISC INTERRUPT SIGNAL

DISCP:	CAIE	D,3;	       SKIP IF DISC RE-ENTRY
	JRST	DISC2
	SETZM	DISC.S
	JSR	DISC.C
	DONE

DISC2:	SKIPE	DSS;		SKIP IF NOT SKULKING
	JRST	SKULK
	SKIPN	S,DIP;		SKIP IF WE DO HAVE A USER
H10:	HALT	10;		DISC INTERRUPT BUT NO DISC USER
	SUBI	S,S.Q;		COMPUTE USER NUMBER
	CHS	COM.S;		ACTIVATE USER FOR INFORMATION TRANSFER
	CAIN	D,2;		SKIP IF NOT A DISCARD
	TSX	ADIS;		ACCOUNT FOR DISC USE
DISC1:	SETZM	DISC.S;		RESET THE SIGNAL
	TSX	TRST;		RESTART THE TAPE
	DONE

;	SEARCH FOR GRONKED USERS

GRONK:	MOVEI	S,N.S-1
GR1:	LDB	B,S.GK
	JUMPN	B,GR3
GR2:	SOJGE	S,GR1
	SETZM	CKER
	DONE

GR3:	MOVEM	S,CUI
	MOVEI	A,71
	JRST	KILL

; PG. 78 - INTER-CONSOLE SYNCHRONIZING SIGNALS

	SUBTTL	INTER-CONSOLE SYNCHRONIZING SIGNALS
	
	;	THESE ROUTINES ARE CALLED BY THE INTERPRETER TO SET (SSIG),
	;	RESET (RSIG),  AND TEST (TSIG) THE INTER-CONSOLE SIGNAL BITS.
	;	ENTRY VIA PUSHJ 0,ROUTINE.
	;	REGISTERS LISTED BELOW ARE PRESUMED FREE AND NOT SAVED.
	U=1
	V=2
	W=3
	X=4
	Y=5
	Z=6
	
	;	GET SIGNAL TABLE INDEX
	

	;	INPUT:	"TO" USER IN CUI
	;			"FORM" USER IN U
				
	;	RETURNS:"TO" INDEX IN Z
	;			"FROM" BIT IN V FOR SETTING AND TESTING
				
	;	DESTROYS W
	
	GTI:	MOVE	V,U
			ASH		V,-5;			HIGH ORDER PART OF "FROM"
			MOVE	Z,CUI
			IMULI	Z,S.M
			ADD		Z,V;			COMPUTE "TO" INDEX
			MOVE	W,U
			ANDI	Z,37;			MASK IN LOW ORDER OF "FROM"	
			MOVEI	V,1
			ASH		V,0(W);			SHIFT TO PROPER POSITION (HIGH ON LEFT)
			POPJ	0,0
			
	;	RESET A SIGNAL BIT
	
	;	THE BIT "TO" CURRENT USER "FROM" (U) IS RESET
	
	RSIG:	PUSHJ	GTI;			GET TABLE INDEX
			MOVE	W,TTT(Z)
			TDZ		W,V
			MOVEM	W,TTT(Z)
			POPJ	0,0
			
	; 	TEST A SIGNAL BIT
	
	;	THE BIT "TO" CURRENT USE "FROM" (U) IS TESTED.
	;	REGISTER V IS NON-ZERO IF BIT IS SET.
	
	TSIG:	PUSHJ	GTI
			MOVE	W,TTT(Z)
			TDNN	W,V
			SETZM	V
			POPJ	0,0


;PG. 79 - INTER-CONSOLE SYNCHRONIZING SIGNALS
			
	;	SET A SIGNAL BIT
	
	;	THE BIT "TO" (U) "FROM" CURRENT USER IS SET
	
	SSIG:	EXCH	U,CUI
			PUSHJ	GTI
			MOVE	W,TTT(Z)
			TDO		W,V
			MOVEM	W,TTT(Z)
			EXCH	U,CUI
			
	;	RE-ENABLE SIGNALLED USER IF WAITING
	
			EXCH	PP,PPSAV;			GET MONITOR PUSH REGISTER
			MOVE	Z,S;				SAVE TO REGISTER S
			MOVE	S,U;				"TO" USER TO S
			LDB		W,S.SIG
			SKIPE	W;					SKIP IF NOT WAITING
			CHS		COM.S;				ACTIVATE USER
			MOVE	S,Z;				RESTORE S
			EXCH	PP,PPSAV;			RESTORE PP
			POPJ	0,0
			
			
	
	;	TABLE OF INTER-CONSOLE SIGNALS
	
	;	ONE WORD PER 32 STATIONS PER STATION
	;	BITS ACROSS THE WORD CORRESPOND TO THE "FROM" CONSOLE
	;	AND WORDS OR GROUPS DOWN THE TABLE TO THE "TO" CONSOLE.
	
	TTT:	ZBLOK	S.M*N.S
	
	
SUBTTL DISC ACCOUNTING ROUTINES
;PG. 80 - DISC ACCOUNTING ROUTINES

	;		MIDNIGHT DISC SKULKER
	
	MDS:	SKIPE	DSS
			JRST	RESK
			SKIPE	DKBY
			JRST	MDS2
			
	;		START OR RESTART SKULK
	
	RESK:	CONSZ	PI,CHDC;			SKIP IF DATA CONTROL IDLE
			JRST	MDS2
			SETZM	SKT
			AOS		SKR;				FLAG DISC USING DC
			SETZM	B
			SKIPN	DSS
			HRLI	B,1;				INITIALIZATION BIT FOR IDG
			AOS		DSS;				FLAG SKULKING
			AOS		DKBY;				BUSY THE DISC
			HRRI	B,^D1000;			REQUEST SKULK FROM DISC PROCESSOR
			MOVEM	B,ACTION
			JSR		DISC.C
			DONE
			
	MDS2:	AOS		SKT;				FLAG START REQUEST
			DONE

;PG. 81 - DISC ACCOUNTING ROUTINES

	SKULK:	SETZM	SKR;				DISC NOT USING DC
			MOVE	B,RESULT
			CAIN	B,^D12
			JRST	SK5;				DISC ERROR
			CAIE	B,^D100;			SKIP IF RECORD READY
			JRST	SK1
			MOVEI	B,^D9
	SK3:	MOVE	A,DBUF(B)
			TLNE	A,777777
			TSX		TLT;				CONVERT ASCII TO BINARY
			TLNE	A,777777
			MOVEM	F,DBUF(B)
			ADDI	B,5
			CAIGE	B,^D134
			JRST	SK3
			MOVE	S,[DEC -2];			CONTEXT FOR TAPE
			MOVEI	E,DBUF
			TSX		PUTB;				START TO TAPE
			JRST	DISC1;				GO TO RESTART THE TAPE
			
	SK1:	CAIE	B,^D2000;			SKIP IF NO MORE ERRORS
	H21:	HALT	21;					UNKNOWN ENTRY FROM DISC ROUTINES
			TSX		CMESS
			XMT 10,SK11;	SAY SKULK COMPLETE
			
	
	SK4:	SETZM	DISC.S
			SETZM	DSS
			SKIPN	S,DQ
			JRST	SK2
			SUBI	S,S.Q
			CHS		COM.S;				ENABLE WAITING DISC USER
			DONE
			
	SK2:	SETZM	DKBY
			DONE
	
	SK5:	TSX		CMESS
			XMT 10,SK10; SAY NO SKULK
			JRST	SK4
			
	SK10:	ASCII	?NO SKULK?
	
	SK11:	ASCII	?SKULK OK?
	
	
			DSS:	Z;					SET IF WE ARE SKULKING
			SKT:	Z;					SET WHEN TAPE OUTPUT COMPLETE
			SKR:	Z;					SET IF DISC USING DC FOR SKULK
			

SUBTTL SHUTDOWN PROCEDURE
; PG. 82 - SHUTDOWN PROCEDURE

	;		SHUTDOWN JOSS SYSTEM
	
	SDP:	SETZB	D,N.SON;			ALLOW NO MORE ON
			MOVEI	C,1
			ORM		C,SWITCH;			BE SURE A MESSAGE IS GOING OUT
			MOVEI	C,QM-S.QUE;			TEST ALL BUT QUEUE AND OF
			OR		D,S.QUE-1(C);
			SOJG	C,.-1
			SKIPE	D;					SKIP IF ALL IS QUIET
			DONE	;					STILL SOME ACTION
			HRREI	S,-1;				TTY CONTEXT
			TSX		ODIS
			TSX		TWAIT
			CONO	MTC,1400;			END FILE LOG
			TSX		TWAIT
			CONO	MTC,7400;			BACK OVER IT
			TSX		CMESS
			XMT	23,TERM;  SYSTEM ALL DOWN
			
			CONO	PI,1000+CHAPR;		TURN OFF PROCESSOR INTERRUPTS
			SETZM	SWITCH;				BE SURE BEEP WONT INTERFERE
			JSR		SHUT;				TURN OFF ALL CONSOLES
			JRST	.

	TERM:	ASCII	?SYSTEM HAS SHUTDOWN?
	
	

; PG. 83 - MONITOR-DISTRIBUTOR INTERFACE

	SUBTTL	MONITOR-DISTRIBUTOR INTERFACE
	
	;		PROCESS DISTRIBUTOR SIGNALS
	PRSIG:	MOVEI	G,0;				ZERO ENTRY COUNT
	SP1:	HRRZ	S,SIGTBL(G) ;		GET ENTRY (XWD,SIGTYPE,STN#)
			HLRZ	B,SIGTBL(G) ;		TYPE
			CAMLE	S,S.OK
			JRST	SP3;				WE ARE IGNORING THIS GUY
			CAILE	B,^D5;				TEST FOR WITHIN SIGNAL LIMIT
	H6:		HALT	6;					BAD SIGNAL FROM IRWIN
			LDB		F,S.STA;			GET STATE
			LDB		C,T2(B);			GET NAME OF PROPER ROUTINE
			XCT		T3(C);				DO IT
	SP3:	CONO	PI,1000+CH630;		TURN OFF 630 INTERRUPTS
			AOS		G;					BUMP ENTRY COUNT
			CAML	G,SG.L;				COMPARE WITH LENGTH
			JRST	SP2
			CONO	PI,2000+CH630;		TURN ON 630 INTERRUPTS
			JRST	SP1;				GO BACK FOR NEXT ITEM
	SP2:	SETZM	SG.L;				ZERO THE SIGNAL LIST
			CONO	PI,2000+CH630;		TURN ON 630 INTERRUPTS
			HRRZ	S,FAKE
			HRLZ	S,FAKE
			TRZN	B,400000;			SKIP IF PSEUDO SIGNAL
			DONE
			CAILE	B,4;				SKIP IF LEGITIMATE SIGNAL
			DONE
			CAILE	S,N.S;				SKIP IF LEGITIMATE STATION
			DONE
			LDB		F,S.STA;			GET STATE
			LDB		C,T2(B)
			XCT		T3(C);				DO THE ACTION ROUTINE
			SETZM	FAKE;				FLAG DONE
			DONE
; PG.84 - TABLES FOR SIGNAL INTERPRETATION
	SUBTTL	TABLES FOR SIGNAL INTERPRETATION
	
	
	T2:		POINT	7,T1(F),6;		TABLE OF POINTER TO COLUMNS IN T1
			POINT	7,T1(F),^D13
			POINT	7,T1(F),^D20
			POINT	7,T1(F),^D27
			POINT	7,T1(F),^D34
			
			RADIX	10
	;				ROUTINE NAME TABLE FOR GIVEN SIGNAL AND STATE
	;				COLUMNS ARE: TO,IN,ON,OFF,CR
	
	T1=.
			BYTE	(7)		1,1,1,1,1;	TOF
			BYTE	(7)		1,1,1,9,0;	ON
			BYTE	(7)		0,6,1,9,0;	RC
			BYTE	(7)		13,1,1,9,0;	RI
			BYTE	(7)		13,1,1,9,0;	RIB
			BYTE	(7)		13,5,1,9,0;	UC
			BYTE	(7)		13,6,1,15,0;	QC
			BYTE	(7)		13,4,1,15,0;	COM
			BYTE	(7)		0,0,0,0,0;	CU
			BYTE	(7)		13,6,1,14,0;	DCT
			BYTE	(7)		13,6,1,14,0;	DIP
			BYTE	(7)		12,5,1,9,0;	CK
			BYTE	(7)		13,16,1,14,0;	DQ
			BYTE	(7)		0,1,1,9,3;	GR
			BYTE	(7)		11,1,1,9,0;	DSU
			BYTE	(7)		13,1,1,9,0;	ABG
			BYTE	(7)		13,4,1,15,0;	QP
			BYTE	(7)		13,6,1,15,0;	QDM
			BYTE	(7)		13,7,1,8,0;	QM
			BYTE	(7)		1,1,10,1,1;		OF
			RADIX	8

	;		TABLE OF ROUTINES FOR SIGNAL INTERPRETATION
	
		T3:	HALT	20;		0 - MACHINE ERROR HALT
			NOP;			1 - IGNORE SIGNAL
			NOP;			2 - UNUSED
			TSX		CR.R;	3 - GENERAL CR RESPONSE
			TSX		IN10;	4 - CHANGE TO RI STATE
			TSX		IN20;	5 - CHANGE TO RIB STATE
			TSX		IN50;	6 - RECORD IN SIGNAL
			TSX		IN40;	7 - SEND QUEUE MESSAGE
			TSX		OFFQ;	8 - OFF FROM USER IN THE QUEUE
			TSX		OFFNQ;	9 - OFF FROM ALL OTHERS
			TSX		ON.R;	10 - ON FROM OFF STATION
			TSX		TODSU;	11 - TO FROM STATION IN DSU
			TSX		TOCK;	12 - TO FROM CHOKED STATION
			TSX		TO99;	13 - TO FROM ALL OTHERS
			TSX		OFFD;	14 - FROM A DISCING USER
			TSX		OFF5;	15 - OFF FROM MORE CORE
			TSX		IN30;	16 - INTERRUPT FROM DISC ISSUE
			Z;				SPARE
		H20=T3
		

; PG. 85 - SEND MESSAGES TO ALL IN THE QUEUE

	SUBTTL	SEND MESSAGES TO ALL IN THE QUEUE
	
		SAQM:	HRRZI	F,1;		INITIALIZE PLACE IN QUEUE
				HRRZ	D,QM;		ADDRESS OF FIRST
		SA1:	HRRZ	S,D
				SUBI	S,S.Q;		COMPUTE USER INDEX
				TSX		GETBUF
				DONE
				TSX		SQM;		SEND MESSAGE
				HRRZ	D,0(D) ;	NEXT USER
				AOS		F;			BUMP PLACE IN QUEUE
				JUMPN	D,SA1;		GO AROUND IF MORE USERS
				DONE

; PG. 86 - OFF-SIGNAL ROUTINES

	SUBTTL	OFF-SIGNAL ROUTINES
	
	OFFQ:		SOS		CT28;		OFF FROM USER IN THE QUEUE
				SETZM	MINT(S);	ZERO INITIALS
				CHS		OF.S
				FSW H
				
				TRNN	H,OFFS;		DON'T RE-ENABLE IF BLAST-OFF
				JSR		C31;		RE-ENABLE
				MOVE	H,S
				SKIPE	QM;			SEND MESSAGES TO ALL IN QUEUE
				TSX		SAQM
				MOVE	S,H
				JRST	OFF
	OFFNQ:		SOS		USERS;		OFF FROM USER NOT IN QUEUE
				CHS		TOF.S
	OFF:		MOVE	E,S.BUF(S);	STATION BUFFER HEADER
				JUMPE	E,OF1;		JUMP IF NO MORE BUFFERS AVAILABLE
				TSX		MBA;		PUT BUFFER ON AVAILABLE
				JRST	OFF;		CONTINUE TILL ALL ARE PUT AWAY
				
	;					TURN ON A USER FROM THE QUEUE IF PROPER
	
	OF1:		SKIPN	QM;			SKIP IF SOME IN QUEUE
				DONE
				
	OF2:		MOVE	E,USERS
				CAML	E,N.SON;	SKIP IF USERS < MAX
				DONE
		
				HRRZ	S,QM
				SUBI	S,S.Q;		INDEX OF TOP USER IN QM
				SKIPE	S.BUF(S)
				DONE;
				CHS		ON.S;		CHANGE STATE TO "ON"
				SOS		CT28;		DECREMENT # IN QUEUE
				AOS		USERS
				SKIPE	QM;			TEST FOR NONE IN THE QUEUE
				TSX		SAQM;		SEND MESSAGES TO ALL IN QUEUE
				
	OFF5:		LDB		A,S.DU
				JUMPE	A,OFFNQ;	JUMP IF NOT USING DISC
	OFFD:		MOVEI	A,1
				DPB		A,S.OFR;	FLAG USER OFF DURING DISC TRANSFER
				DONE


; PG. 87 - ON-SIGNAL ROUTINES

	SUBTTL	ON-SIGNAL ROUTINES
	
	ON.R:		HRRZ	E,USERS;	GET NUMBER OF USERS
				CAMGE	E,N.SON;	BIGGER THAN MAX
				JRST	ON5;		NO, GO TO TURN ON.
				CHS		QM.S;		CHANGE STATE TO "QUEUE MESSAGE"
				AOS		F,CT28;		COUNT AND FETCH QUEUE #
				TSX		GETBUF;		GET A BUFFER
				DONE;				NONE, FORGET IT
				TSX		SQM;		SEND QUEUE MESSAGE
				DONE
				
	ON5:		CHS		ON.S;		CHANGE STATE TO "ON"
				AOS		USERS;		COUNT USERS
				DONE


; PG. 88 - SEND A QUEUE MESSAGE

	SUBTTL SEND A QUEUE MESSAGE
	
	SQM:		MOVE	C,[POINT 7,MINT(S) ]
				INS		"Q"
				INS		"#"
				MOVE	A,F
				TSX		CTDB;		PUT QUEUE # IN FOR INITIALS
				INS		" "
				CAIGE	F,^D10
				INS		" "
				MOVE	A,F;		RECOVER QUEUE #
				MOVE	C,[POINT 7,QM2,6]
				TSX		CTDR;		CONVERT AND DEPOSIT QUEUE #
				MOVE	C,[POINT 7,QM4]
				MOVE	A,HR
				TSX	CTDR;		CONVERT AND DEPOSIT HOURS
				IBP		C;			SKIP PAST THE COLON
				MOVE	A,MIN
				TSX		CTD;		CONVERT AND DEPOSIT IN MINUTES
				SEND	QM1;		"YOU ARE # IN THE QUEUE"
				FSW		A
				
				TRNE	A,SDS;		IF SHUTTING DOWN
				SEND	SDM;		SEND SHUT DOWN MESSAGE TO QUEUE
				TSX		PUTB;		SEND TO USER
				DONE
				
				
	QM1:		XWD		.+1,QM3-.-1
				OCT		64241203416;	CR,LF,LF,BELL,BELL
	QM4:		ASCII	/HH:MM/
				OCT		202635772500;	YOU
				OCT		607454520334;	ARE N
				OCT		727334262744;	UMBER
	QM2:			OCT		202613020322;	 XX I
				OCT		671016464312;	N THE
				OCT		203436562752;	 QUEU
				OCT		625341500000;	E."CR"
	QM3=.
	

; PG. 89 - CONVERT TO TWO DECIMAL CHARACTERS

	SUBTTL	CONVERT TO TWO DECIMAL CHARACTERS
	
	;			(A) ARE CONVERTED TO CHARACTERS AT POINTER IN C,B DESTROYED
	
	CTD:		IDIVI	A,^D10;
				JRST	CTD1;			OUTPUT HIGH ORDER ZEROS
				
	CTDB:		IDIVI	A,^D10;			CONVERT TWO DIGITS TO ASCII
				JUMPE	A,CTD2;			SUPPRESS LEADING ZEROS
				JRST	CTD1
				
	CTDR:		IDIVI	A,^D10
				JUMPN	A,CTD1
				MOVEI	A," ";				REPLACE LEADING ZEROS WITH BLANKS
				JRST	.+2
	CTD1:		ORI		A,60
				IDPB	A,C
	CTD2:		ORI		B,60
				IDPB	B,C
				DONE

	;					COMPUTE BINARY SECONDS FROM CLOCK CELLS
	
	ISEC:		MOVE	B,HR
				IMULI	B,^D60
				ADD		B,MIN
				IMULI	B,^D60
				ADD		B,SEC
				DONE
				

; PG. 90 - IN-SIGNAL ROUTINE

	SUBTTL	IN-SIGNAL ROUTINE
	
	IN10:		LDB		B,S.DU
				SKIPE	B;				SKIP IF NOT A DISC USER
				JRST	IN50;			FROM DISC USER: FLAG IT
	IN11:		CHS		RI.S;			CHANGE TO REQUEST IN STATE
				JRST	IN99
				
	IN20:		CHS		RIB.S
				JRST	IN99
				
	IN30:		SETZM	B
				DPB		B,S.DU;			RESET DISC FLAG
				JRST	IN11
				
	IN40:		TSX		GETBUF
				JRST	IN99;			FORGET IT IF NO BUFFER
				MOVEI	F,1;			INITIALIZE QUEUE COUNT
				HRRZ	B,QM
				CAIN	B,S.Q(S);		SKIP IF NOT THE  ONE OF INTEREST
				JRST	.+3
				HRRZ	B,0(B)
				AOJA	F,.-3;			COUNT PLACE IN QUEUE
				TSX		SQM;			SEND HIM THE MESSAGE
	IN99:		AOS		CT27;			COUNT INS WHICH RESULT IN ACTION
				DONE
				
	IN50:		MOVEI	A,1
				DPB		A,S.INR;		FLAG INTERRUPT SIGNAL
				JRST	IN99
				

; PG.91 - CARRIER-RETURN-SIGNAL ROUTINES
	
	SUBTTL	CARRIER-RETURN-SIGNAL ROUTINES

	CR.R:		AOS		CT31;			COUNT CARRIAGE RETURNS
				AOS		T7+2
				HRRZ	E,S.BUF(S);		GET BUFFER LOCATION
				HLRE	D,2(E);			GET CHARACTER COUNT
				SKIPGE	D
				SETCMM	D;				COMPLEMENT  IF TTY STATION
				ADDM	D,CT25;			GROSS SUM
				TSX		CVTLIN;			FROM DISTRIBUTION
				AOS		CPIL(B)
				HRRZ	B,USTAT(S) ;	TICKS SINCE LAST CR
				IMULI	B,^D60;			SCALE
				JSR		CVTL
				AOS		DCPI(C);		COUNT COMP/INTERACTION IN RANGE
				TSX		ISEC;			CURRENT TIME IN SECS
				HRLZ	C,USTAT(S) ;	LAST GREEN TIME
				HRLZM	B,USTAT(S) ;	THIS GREEN TIME
				SUB		B,C
				SKIPGE	B
				ADDI	B,^D24*^D3600;	MIDNIGHT CORRECTION
				IMULI	D,^D10;			UNITS ARE NOW 1/10TH MINUTE
				JSR		CVTL
				AOS		DTIM(C);		INTERACTION TIME DISTRIBUTION
				CHS		RC.S;			CHANGE STATE TO CR
				DONE

	;			CONVERT TO LINEAR RANGE

	CVTLIN:		MOVEI	B,0
				MOVEI	C,5
	CVT1:		CAMG	D,C
				DONE
				ADDI	C,5
				CAIGE	B,^D9
				AOJA	B,CVT1
				DONE
				

; PG. 92 - TRANSMISSION-OVER-SIGNAL ROUTINES

	SUBTTL	TRANSMISSION-OVER-SIGNAL ROUTINES
	
	TO:			SKIPN	S.BUF(S) ;		HALT IF NO BUFFER
	H7:			HALT	7;				NO SUCH BUFFER
				AOS		CT16;			COUNT LINES
				AOS		T7+3
				HRRZ	E,S.BUF(S);		CHARACTER COUNT
				HRRZ	D,2(E)
				ADDM	D,CT26;			GLOBAL COUNT
				TSX		CVTLIN;			FIND DISTRIBUTION RANGE
				AOS		CPOL(B)
				MOVS	B,S.BUF(S) ;	PICK UP BUFFER HEADER
				XOR		B,S.BUF(S) ;	SEE IF LEFT=RIGHT
				JUMPE	B,TO1;			JUMP IF LAST BUFFER
				TSX		MBA;			PUT BUFFER ON AVAILABLE LIST
				CALL	C27;			INITIALIZE TRANSMISSION
				AOS		0(PP);			BUMP TO SECOND EXIT
	TO1:		DONE
	
	TODSU:		TSX		TO;				TO PREAMBLE
				TSX		SG;				LAST BUFFER SO CHANGE TO GREEN
				DONE
	
	TOCK:		TSX		TO;				"TO" PREAMBLE
				JRST	TOCK1;			ALWAYS UNCHOKE ON LAST BUFFER
				MOVE	E,N.UC;			GET UNCHOKE #
				HRRZ	B,S.BUF(S)
				JUMPE	B,TO3;			GET UNCHOKED (# BUFFERS <= CK #)
				HRRZ	B,0(B)
				SOJLE	E,.-2
				DONE;					STAY CHOKED (# BUFFERS > CK #)
				
	TOCK1:		TSX		MBA
	TO3:		CHS		UC.S;			CHANGE STATE TO UNCHOKE
				DONE
	
	TO99:		TSX		TO;				"TO" PREAMBLE
				TSX		MBA;			LAST BUFFER- MAKE IT AVAILABLE
				DONE
SUBTTL SWITCH CONSOLE TO GREEN STATE

SG:	HRRZ	B,S.BUF(S);	POINTER TO BUFFER
	MOVE	E,BLANKS
	MOVEM	E,3(B);		BLANK FIRST TEXT WORD
	MOVE	E,B
	ADDI	E,BUFSIZ;	LAST BUFFER LOCATION
	ADDI	B,3;		BUMP DOWN TO FIRST TEXT WORD
	HRL	B,B
	AOS	B;		MAKE UP BLT CONTROL WORD
	BLT	B,0(E);		BLANK THE BUFFER
	TSX	ISEC
	HLRZ	C,USTAT(S)
	SUB	B,C;		TASK TIME: CR TO SG
	SKIPGE	B
	ADDI	B,^D24*^D3600
	IMULI	B,^D60;		DISPLAY UNITS ARE 1 SECOND
	JSR	CVTL
	AOS	T8(C)
	CHS	GR.S;		SWITCH TO GREEN STATE
	CALL	C28;		SWITCH TO USER
	DONE

SUBTTL ACCUMULATE COUNTS ON THE MINUTE

QCTR:	SETZM	A
	JUMPE	B,.+4
	HRRZ	B,0(B)
	AOS	A
	JUMPN	B,.-2
	DONE

GETCT:	QCT GR,CT33; COUNT GREEN QUEUE
	QCT COM,CT34;         COUNT COMPUTE QUEUE
	QCT CK,CT35; COUNT WAIT FOR BUFFER QUEUE
	MOVE	A,CT44;		CUMULATIVE COMPUTE TIME
	IMULI	A,^D10000;	SCALE
	IDIV	A,TIME
	MOVEM	A,CT43;		1/100THS % OF TOTAL TIME
	MOVEI	C,1
GT1:	MOVE	A,CT27A(C)
	IDIVI	A,^D8
	IMULI	A,2
	ADDM	A,CT27A(C);	MAKE LOG PRINT OCTAL STATION #
	SOJGE	C,GT1;		CT27A AND CT27B
	MOVE	B,CT13;		TICKS THIS MINUTE
	IMULI	B,^D1000
	IDIVI	B,2;		DISPLAY AT 2MS.
	IDIV	B,CT14;		1/10THS OF MS./STATEMENT
	JSR	CVTL
	SKIPE	CT14;		SKIP IF NO STATEMENTS INTERPRETED
	AOS	T5(C);		RECORD IN DISTRIBUTION
	DONE

SUBTTL DISPLAY USERS INITIALS AND STATION NUMBER

;	USES REGISTERS A,B,C,D,E,F,G. S MUST CONTAIN CONTEXT FOR OUTPUT

DISINT:	MOVE	D,[XWD -N.S,0];	WELL CHECK ALL STATIONS
DI1:	MOVEI	G,^D8;		AND OUTPUT 8 PER LINE
	TSX	CMESS
	TSX	DI2;MAKE UP INITIALS LINE
	JUMPL	D,DI1;		BACK AROUND IF MORE STATIONS
	DONE

DI2:	SKIPN	F,MINT(D);	SKIP IF INITIALS ARE THERE
	JRST	DI3;		NONE ON THAT STATION
	HRRZ	A,D
	TSX	OCT;		CONVERT STA # TO OUTPUT
	XMT 5,F;    AND THE INITIALS
	SOS	G;		COUNT INITIALS IN BUFFER
DI3:	AOBJP	D,DI4;		JUMP IF WE HAVE FINISHED THE TABLE
	JUMPG	G,DI2;		JUMP IF BUFFER NOT FULL
DI4:	DONE

SUBTTL INITIALS FOR ON AND OFF SIGNALS

,	DISPLAY LOG-ONS AND LOG-OFFS IF PSEUDO SWITCH DOAF IS SET
,	D CONTAINS "ON-" OR "OFF-"
;	DESTROYS A,B,D,E,S.

DOF:	FSW A;	    GET THE SWITCHES
	TRNN	A,DOAF;		SKIP IF DISPLAY INDICATED
	DONE
	HRRZ	F,S
	TSX	CMESS
	TSX	DOF1;		MAKE UP LOG ON/OFF LINE
	DONE

DOF1:	XMT 4,D;    "ON" OR "OFF"
	HRRZ	A,F
	TSX	OCT;		CONVERT STA # TO OUTPUT
	XMT 5,INITIALS
	DONE


,	CONVERT STATION # TO OCTAL ASCII (TWO DIGITS ONLY)

OCT:	TSX	OCT1
	INS	"I"
	DONE

OCT1:	IDIVI	A,10
	ORI	A,60
	IDPB	A,C;		CONVERT AND OUTPUT STA #
	ORI	B,60
	IDPB	B,C
	DONE

; PG. 97 - DISPLAY STATISTICAL DISTRIBUTIONS

	SUBTTL DISPLAY STATISTICAL DISTRIBUTIONS
	
	ODIS:	MOVEI	F,STAT2;		DISPLAY TABLE SIZE
			MOVE	J,STAT1(F);		STAT TABLE POINTER
			TSX		TABO;			FORMAT AND OUTPUT STAT LINE
			SOJGE	F,.-2
			DONE
			
	STAT1:
			XWD		0,T1;			T11, T10, AND T9 ARE USED
			XWD		0,T10;			BY JOE TO RECORD COUNTS OF EXECUTION
			XWD		0,T9;			BY VERB TYPE
			XWD		0,TINT;			TOTAL I/O CHARACTERS
			XWD		0,OINT;			OUTPUT INTERRUPTS
			XWD		0,IINT;			OUTPUT INTERRUPTS
			XWD		0,CPOL;			CHAR/OUTPUT LINE
			XWD		0,CPIL;			CHAR/INPUT LINE
			XWD		0,DSIZE;		SIZE
			XWD		0,DCPI;			COMPUTE TIME PER INTERACTION
			XWD		0,DTIM;			INTERACTION TIME
			XWD		0,CCTIM;		COMPUTE TIME
			XWD		0,SESTIM;		SESSION TIME
			XWD		0,T5;			INTERPRETATION RATE
			XWD		0,T8;			TASK TURN-AROUND TIME
			XWD		0,T7;			MISC. STATISTICS
			XWD		0,T6;			GENERAL COUNTS AND BLOCKSIZE DISTRIB.
	STAT2=.-STAT1-1
	


; PG. 98 - COUNT TIME AND GATHER STATISTICS

	STAT:	MOVE	B,SEC
			CAIN	B,^D30
			TSX		TRST;			RESTART TAPE
			SUBI	B,^D60
			JUMPL	B,ST2.6;		DONE IF NOT A NEW MINUTE
			
	;		NEW MINUTE
	
			HRREI	S,-1;			CONTEXT FOR CONSOLE I/O
			MOVEM	B,SEC
			TSX		UP1;			CONVERT DATE TO ASCII IN CASE OF RECURRENT CHANGE
			AOS		B,MIN;			BUMP THE MINUTE COUNT
			IDIVI	B,K3;
			FSW D
			
			TRNN	D,DUI;			CHECK DISPLAY SWITCH
			SKIPN	C;				DISPLAY INITIALS IF FP(MIN/K3)=0
			TSX	DISINT
			FSW		D
			
			TRZN	D,DSTAT;		SKIP IF WE ARE TO DISPLAY STATISTICS
			JRST	STA3
			MOVEM	D,SWITCH
			TSX		ODIS;			DISPLAY STATISTICS
	STA3:	FSW D
	
			TRNN	D,OLSW;			SKIP IF DISPLAY
			JRST	STA1
			MOVEI	F,STAT2+1
			LDB		J,C5
			CAILE	J,STA2
			JRST	STA1
			JUMPE	J,STA1
			SUB		F,J
			MOVE	J,STAT1(F)
			TSX		TABO
			

; PG. 99 - COUNT TIME AND GATHER STATISTICS

	STA1:	MOVE	D,[POINT 6,CT48A]
			MOVEI	B,4
			AOS		T6
			ILDB	C,D
			ADDM	C,T6+5(B)
			SOJG	B,.-2
			MOVE	B,CT18
			ADDM	T6+5;			TOTAL SAVES
			MOVE	B,CT19
			ADDM	B,T6+4;			TOTAL LOADS
			MOVE	B,CT19A
			ADDM	B,T6+3;			TOTAL DRUM ACTIONS
			MOVE 	B,CT14
			ADDM	B,T6+1;			TOTAL STATEMENTS
			MOVE 	B,CT13
			ADDM	B,T6+1;			TOTAL TICKS
			MOVE	B,CT18A
			ADDM	B,T7;			DISCARDS
			SKIPE	CT11;			SKIP IF A FULL USE MINUTE
			JRST	STA1.5
			AOS		T7+7;			COUNT THEM
			MOVEI	B,^D3600
			SUB		B,CT13;			COMPUTE OVERHEAD TICKS
			ADDM	B,T7+8;			AND ACCUMULATE THEM
	STA1.5:	MOVE	B,MIN
			SUBI	B,^D60
			JUMPL	B,ST1;			JUMP IF NOT A NEW HOUR
			
	; 		NEW HOUR
	
			SETZM	CT17
			SETZM	CT23;			CLEAR LOG COUNTERS
			
			MOVEM	B,MIN;			UPDATE MINUTES
			AOS		B,HR
			TRNN	B,3;			OUTPUT STATISTIC EACH FOUR HOURS
			TSX		ODIS
			MOVE	B,HR
			SUBI	B,^D24
			JUMPL	B,STA2;			JUMP IF NOT A NEW DAY
			MOVEM	B,HR
			TSX		UDATE;			GO TO INCREMENT DATE
	STA2:	TSX		HMES;			HEADING LINE
			JRST	ST1
SUBTTL TAPE OUTPUT ROUTINE

,	HANDLES ALL TAPE OUTPUT EXCEPT ACCOUNTING FOR RECORDS

SOUT:	TSX	GETBUF
	DONE
	HRL	D,B
	HLR	D,(B);		CONTROL WORD FOR MOVE
	SUBI	E,2;		FAKE UP FOR MOVE ROUTINE
	HRLI	E,D;		CONTROL WORD ADDRESS
	TSX	BJ9.1;		MOVE WORDS TO BUFFER
	ADDI	E,2;		RESTORE
	TSX	PUTB;		START OUTPUT
	DONE

SUBTTL OUTPUT CUMULATIVE STATISTICS LINE

;	OUTPUTS TABLE OF SIZE 10 FROM (J), USES LOTS OF REGISTERS

TABO:	TSX	CMESS
	TSX	TABO1;		FORMAT THE LINE
	DONE

TABO1:	HRREI	H,-12
ST.1:	MOVEI	G,6;		FIELD SIZE
	MOVEI	I," ";		  ALTERNATE OUTPUT CHARACTER
	SETZM	D;		INITIAL OVERPUNCH
	MOVE	A,0(J);		GET ELEMENT FROM TABLE
	AOS	J
	TSX	FRMT;		FORMAT ELEMENT FOR OUTPUT LINE
	AOJN	H,ST.1
	XMT 5,ST.12
	MOVEI	A,STAT2+1
	SUB	A,F
	TSX	CTD;		OUTPUT LINE NUMBER ON STATISTICS
	DONE

ST.12:	ASCII	?   # ?

SUBTTL OUTPUT HOURLY HEADING LINE

HMES:	TSX	CMESS
	TSX	HMES1
	DONE

HMES1:	INS	12;		LINE FEED
	MOVE	A,DR
	TSX	CTD;		HOURS TO HEADING LINE
	INS	":"
	INS	" "
	XMT 10,DATE
	XMT 2,CRLF
	XMT 110,HEAD;	      72 HEADING CHARACTERS
	DONE

SUBTTL OUTPUT DETAIL STATISTICS ON THE MINUTE

ST1:	TSX	GETCT;		COMPUTE NEW COUNTS
ST1B:	SKIPE	MIN
	JRST	.+3
	SETZM	TIME;		RESET COMPUTE % ON THE HOUR
	SETZM	CT44
	MOVE	B,CT25
	ADD	B,CT26
	ADD	B,CT27A
	ADD	B,CT27B
	JUMPE	B,ST2.5-1;	NO OUTPUT IF NO ERRORS OR CHAR.
	TSX	CMESS
	TSX	ST1A;		FORMAT TO BUFFER
	HRREI	B,-CTPARS
ST2.5:	MOVE	E,CTPAR+CTPARS(B);  GET PARAMETER WORD
	TLNN	E,400000;	SKIP IF SHOULD NOT ZERO THE COUNTER
	SETZM	(E)
	AOJL	B,ST2.5
ST2.6:	DONE

;	FORMAT A LINE FOR THE CONSOLE TTY

ST1A:	MOVE	A,MIN
	TSX	CTD;		CONVERT MINUTES
	HRREI	H,-CTPARS;	TABLE SIZE
ST2:	MOVEI	I," ";		SET ALTERNATE OUTPUT CHARACTER
	SETZM	D;		INITIALIZE TO NO OVERPUNCH
	LDB	G,[POINT 5,CTPAR+CTPARS(H),5]; GET FIELD SIZE
	LDB	F,[POINT 12,CTPAR+CTPARS(H),17]; GET SCALE FACTOR
	MOVE	B,CTPAR+CTPARS(H)
	MOVE	A,(B);		GET COUNT
	JUMPN	A,.+3
	MOVEI	D,".";		  ALTERNATE CHAR IF ALL ZERO
	JRST	ST2.4
	IDIV	A,F;		SCALE
	JUMPN	A,ST2.4;	GET REMAINDER IF QUOTIENT IT ZERO
	MOVE	A,B
	IMULI	A,^D10;		MAKE A PLACE FOR THE *
	MOVEI	D,"*";		  MAY HELP BUT IT AINT PERFECT
ST2.4:	TSX	FRMT;		FORMAT THE OUTPUT LINE
	SOJL	H,ST2;		GO AROUND IF MORE COUNTERS
	DONE

SUBTTL ROUTINE TO UPDATE THE DATE

UDATE:	AOS	B,DAY;		ROUTINE TO INCREMENT AND UPDATE THE DATE
	MOVE	D,[POINT 5,MONS]
	MOVE	C,MONTH
	IBP	D
	SOJN	C,.-1;		COUNT DOWN TO THE CURRENT MONTH
	MOVE	C,MONTH
	LDB	A,D
	CAIE	C,2
	JRST	UD2;		NOT FEBRUARY
	MOVE	C,YEAR
	TRNN	C,3;		CHECK FOR LEAP YEAR
	AOSA	A;		LEAP YEAR - AN EXTRA FOR FEB
UD2:	SUB	B,A
	JUMPLE	B,UP1;		NOT A NEW MONTH
	AOS	B,MONTH;	BUMP THE MONTH
	MOVEI	A,1
	MOVEM	A,DAY;		SET DAY = 1
	TSX	MDS;		TIME FOR DISC ACCOUNTING
	MOVE	B,MONTH
	SUBI	B,^D12
	JUMPLE	B,UP1;		NOT A NEW YEAR
	AOS	YEAR
	MOVEI	A,1
	MOVEM	A,MONTH;	SET MONTH = 1

,	CONVERT DATE AND TIME TO ASCII

UP1:	MOVE	A,BLANKS
	MOVEM	A,DATE
	MOVEM	A,DATE +1;	BLANK THE DATE
	MOVEM	A,ATIM;		AND TIME
	MOVE	C,[POINT 7,DATE]
	MOVE	A,MONTH
	TSX	CTDB
	INS	"/"
	MOVE	A,DAY
	TSX	CTDB
	INS	"/"
	MOVE	A,YEAR
	TSX	CTDB
	MOVE	C,[POINT 7,ATIM]
	MOVE	A,HR
	TSX	CTDB;		CONVERT - SUPPRESS LEAD ZEROS
	INS	":"
	MOVE	A,MIN
	TSX	CTD;		CONVERT - WITH LEAD ZEROS
	DONE

ADATE=UP1
	RADIX	10
MONS:	BYTE	(5)31,28,31,30,31,30,31,31,30,31,30,31

	RADIX	8

SUBTTL FORMAT A COUNTER FOR CONSOLE OUTPUT

;	A CONTAINS SCALED COUNTER VALUE, C THE POINTER TO THE
;	OUTPUT LINE, G THE FIELD SIZE, AND I THE ALTERNATE
;	OUTPUT CHARACTER.
;	D, B ARE CLOBBERED.

FRMT:	CAMGE	A,T80(G);	TOO BIT FOR FIELD?
	JRST	ST4;		NO
	MOVEI	D,"!";		  YES, SET OVERPUNCH
ST3:	IDIVI	A,^D10;		SCALE BY TEN
	CAML	A,T80(G);	IF STILL TOO BIG:
	AOJA	D,ST3;		BUMP TO NEXT SPECIAL CHARACTER
ST4:	CAIN	G,1
	MOVEI	I,"0";		  SET ALTERNATE TO ZERO ON LAST COLUMN
	IDIV	A,T80.99(G)
	JUMPN	A,ST5
	MOVE	A,I;		IF ZERO GET ALTERNATE
	JRST	ST6
ST5:	MOVEI	I,"0";		  SET ALTERNATE TO ZERO SINCE WE NOW HAVE A DIG
	ORI	A,60;		ASCII BITS
ST6:	IDPB	A,C;		DUMP IN OUTPUT
	EXCH	A,A+1;		GET REMAINDER
	SOJG	G,ST4;		GO AROUND IF MORE COLUMNS
	JUMPE	D,ST7;		JUMP IF NO OVERPUNCH
	DPB	D,C;		DEPOSIT OVERPUNCH
ST7:	DONE

; PG 106
SUBTTL MONITOR MAIN PROCESSING LOOP

;	MASTER MONITOR ENTRY POINT

SIGPR:	SETZM	T.CU;		KEEP IT FROM COUNTING TOO HIGH
SIGPR1=SIGPR
	FSW B;	    GET DATA SWITCHES
	TRNE	B,SDS
	TSX	SDP;		GO TO SHUTDOWN PROCEDURE
	TRNE	B,OFFS
	TSX	BOFF;		GO TO BLAST OFF PROCEDURE
	SKIPE	CKER
	TSX	GRONK
	SKIPE	S,DCT;		SKIP IF NO DISC RESTART WAITING
	TSX	DSTRT;		TRY THE RESTART
	SKIPE	D,DISC.S;	COMPLETION SIGNAL FROM DISC?
	TSX	DISCP;		KEEP TABS ON THE DISC
	SKIPE	SKT
	TSX	MDS;		TIME FOR NEXT SKULK RECORD
	SKIPE	SG.L
	TSX	PRSIG;		PROCESS SIGNALS FROM DISTRIBUTOR
	TSX	STAT;		DO STATISTICS
	SKIPE	S,ABG
	TSX	MSGPR;		GET A BUFFER FOR AWAITING GREEN
	SKIPE	S,QP
	TSX	PQP;		PROCESS THE PAUSE QUEUE
	SKIPE	QM
	TSX	OF2;		TRY TO ENABLE USER IN THE QUEUE
	SKIPE	SS99;		SKIP IF NO COMPACT FOR IN SWAP
	TSX	SS90;		GO COMPACT
	SKIPE	S,QDM
	TSX	DM90;		TAKE CARE OF SWAPS TO INCREASE CORE
	SKIPN	DMBY
	TSX	SELSWP;		SELECT FOR SWAP
	JRST	SELINT;		GO  TO SELECT FOR INTERPRET

;	PROCESS THE QUEUE FOR TRANSFER TO DRUM

DM90:	SKIPE	DMBY
	DONE
	SUBI	S,S.Q
	CHS	QC.S;		PRIORITY TO COME IN
	LDB	C,S.BLOCK
	SUBI	C,1;		BLOCKS TO GO OUT
	SETOM	DMIN;		INDICATE NO IN REQUESTED
	TSX	OSWAP;		START HIM OUT
	DONE
; PG 107

,		TABLE OF STATES WHICH ARE SEARCHED TO FIND A USER

SI1:	BYTE	(5) TOF.S,ON.S,RC.S,RI.S,RIB.S,UC.S,QC.S,COM.S,END.S

SELINT:	MOVEI	J,10;		COUNT TO SAVE US FROM THE MACHINE
	MOVE	B,[POINT 5,SI1];  GET TABLE POINTER
SI2:	ILDB	C,B;		INDEX TO STATE HEADER
	CAIN	C,END.S;	SKIP IF NOT END
	JRST	SI4;		END OF SEARCH
	SOSGE	J
H30:	HALT	30;		CAIN OR ILDB HAS FAILED
	HRRZ	C,S.QUE(C);	LIST HEADER
	JUMPE	C,SI2;		JUMP IF NOT ENTRY
SI3:	HRRZ	S,C
	SUBI	S,S.Q;		STATION INDEX
	LDB	D,S.COR;	GET CORE CELL
	LDB	F,S.STA;	GET STATE
	JUMPN	D,INTINT;	FOUND ONE; JUMP TO INITIALIZE
	CAIN	F,ON.S;		IS IT ON?
	JRST	SI7;		YES, GO TO FIND CORE
SI3.5:	HRRZ	C,0(C);		NOT IN SO LOOK FURTHER
	JUMPN	C,SI3;		JUMP IF ENTRY EXISTS
	JRST	SI2;		END OF LIST - GO FOR NEXT LIST

,		MONITOR IDLE LOOP

SI4:	SKIPN	DMBY;		CANT FIND WORK; IS DRUM BUSY?
	AOSA	CT11;		NO WORK ADD TO IDLE TIME.

SI4.5:	SKIPN	COM
	JRST	SIGPR;		NOT UNOVERLAPPED IF NO COMPUTE
	AOS	CT12;		UNOVERLAPPED TICKS
	AOS	T7+1
	JRST	SIGPR;		GO PROCESS SIGNALS

;	PG. 108 - SELECT AN IN CORE USER FOR INTERPRETATION
	
	SUBTTL SELECT AN IN CORE USER FOR INTERPRETATION
	
			;PROCESS AN "ON" USER
		
	SI7:	MOVEI	D,0
			SKIPN	CORE(D)
			JRST	SI8;				NOPE
			AOS		D
			CAML	D,N.C;				HAVE WE SEARCHED ALL
			JRST	SI3.5;				YES, THERE ARE NONE AVAILABLE
			JRST	SI7+1;				NO, GO FOR NEXT
			
	SI8:	MOVE	A,CORE(D)
			TLO		A,400000;			SET "IN USE BIT"
			MOVEM	A,CORE(D)
			MOVE	B,D
			DPB		S,S.UR;				SET USER # IN CORE BLOCK
			ADDI	D,BBLOCK;			COMPUTE RELOCATION	
			DPB		D,S.COR;			AND SET IN STATUS WORD
			AOS		CT39;				COUNT IN-CORE USERS
			

;PG. 109 INITIALIZE FOR INTERPRETATION
		
	SUBTTL INITIALIZE FOR INTERPRETATION
	
	,		ON ENTRY F CONTAINS STATE, S THE SELECTED USER, AND
	,		D HIS CORE LOCATION
	
	INTINT:			SUBI	D,BBLOCK
				MOVE	D,CORE(D)
				TLNE	D,200000
				JRST	SI3.5;			NO GO - DRUM IS USING
				SKIPL	S
				CAILE	S,N.S;			S MUST BE 0 <=S <= N.S
	H1:			HALT	1;				BAD USER NUMBER
				MOVE	G,T10.(F);		GET ACTION TABLE ENTRY
				TLNN	G,BUFBIT;		SKIP IF HE NEEDS A BUFFER
				JRST	INT2
				TSX		GETBUF
				JRST	SI3.5;			GET HIM LATER IF NONE AVAILABLE
				MOVE	A,E;			SAVE THE BUFFER POINTER
	INT2:			TSX		SRR;			SET REALLOCATION REGISTER
				TLNE	G,ONBIT;		SKIP IF NOT ON TAPE
				JRST	INT3;			NO TEST IF TURNING ON
				MOVE	B,INITIALS
				CAME	B,MINT(S);		COMPARE INITIALS - CORE COPY
				JRST	KILL1;			THEY DIFFER - BAD USER BLOCK DATA
	INT3:			TLNE	G,INBIT;		SKIP IF NO INTERRUPT SIGNAL
				AOS	RISIG;			SET IN REQUEST
				LDB	S,S.INR
				ORM	B,RISIG;		INTERRUPT SIGNAL TO USER BLOCK
				SETZM	B
				DPB	B,S.INR;		RESET INTERRUPT FLAG
				LDB	B,S.DU
				SKIPE	B
				SETOM	SPARE4;			TELL JOE HE HAS THE DISC
				TLNN	G,RCBIT;		SKIP IF CARRIER RETURN
				JRST	INT1
				HRRZ	A,S.BUF(S);		GET BUFFER POINTER
				SETZM	S.BUF(S);		UNLINK FROM USER,
			INT1:	CHS	CU.S;			SET AS CURRENT USER AND
				MOVE	E,A;			BUFFER POINTER TO COMMUNICATION REG
				LDB	B,S.TM
				MOVEM	B,T.CU;			SET CORRECT TIME IN SHOT
				MOVEI	B,0
				TLNE	G,CORBIT
				MOVEI	B,1;			TELL JOE HE GOT MORE CORE
				JRST	MONE1;			GO EXIT FROM MONITOR
				
			KILL1:	MOVEM	S,CUI;			PLANT USER #
				MOVEM	B,SUM(S);		SAVE BAD INITIALS
				MOVEI	A,73
				JRST	KILL;			KILL

;PG.110 - JOSS LOG-ON PROCESSOR

			SUBTTL	JOSS LOG-ON PROCESSOR

			BJ:	JRST	.+1
				MOVE	D,[POINT 6,CT48A]
				ILDB	B,D
				ADDI	B,1
				DPB	B,D;			COUNT IN BLOCK SIZE DISTRIBUTION
				MOVEI	B,NEXT
				MOVEM	B,INTENT		;INITIALIZE ENTRY
				MOVE	C,CUI
				MOVE	B,[ASCII /???  /]
				MOVEM	B,MINT(C);		INITIALIZE USER INITIALS
				MOVEM	B,INITIALS
				MOVE	B,BLANKS
				MOVEM	B,JOBNO
				SETZM	COMTIM
				SETZM	PAGNO
				SETZM	SPARE1;			ZERO BINARY JOB NUMBER
				SETZM	SPARE2;			ZERO DEPT NUMBER
				SETZM	SPARE3;			CHARGE UNITS
				EXCH	PP,PPSAV
				SETZM	SEQ;			INITIALIZE SEQUENCE
				TSX	ISEC
				MOVEM	B,ONTIME;		SET USERS ON TIME
				MOVE	S,CUI
				HRLZM	B,USTAT(S);		SIMULATE FIRST GREEN TIME
				MOVEI	B,1;			GO FOR A BUFFER
				JRST	BJLEV

		BJ1:		SEND 	BJM1;			"JOSS HERE ... INITIALS PLEASE"
				AOS 	SEQ;			INCREMENT SEQUENCER					
				JRST	BJSU

		BJ2:		TSX	BJA1;			GO TO APPROVE INITIALS
				JRST	BJ2.1;			NO GOOD
				SEND	BJM2;			GOOD - "JOB # PLEASE"
				AOS	SEQ;			INCREMENT SEQUENCER
				JRST	BJSU

		BJ2.1:		SEND	BJM3;			"INITIALS AGAIN"
				JRST	BJSU

;PG. 111- JOSS LOG-ON PROCESSOR
		
		BJ3:		TSX	BJA5;			GO TO APPROVE #
				JRST	BJ3.2;			NO GOOD
				AOS	SEQ		
		BJ3.1:		AOS	SEQ;			GOOD - INCREMENT SEQUENCER
				CALL	A,^D1000;		SKIP IF NOT AN RPN
				JRST	BJ6;			YES, GO TO DEPARTMENT
		BJ3.3:		MOVEI	B,2;			RETURN BUFFER
				JRST	BJLEV;			RETURN WILL BE TO INTERP. FIRST ENTRY
	
		BJ3.2:		SEND	BJM4;			"JOB # AGAIN"
				AOS	SEQ
				JRST	BJSU

		BJ4:		TSX	BJA5;			GO TO APPROVE JOB #
				JRST	.+2
				JRST	BJ3.1;			JOB # OK
				SEND	BJM5;			"ARE YOU PLAYING?"			
		BJSU:		MOVEI	B,4
		BJLEV:		EXCH	PP,PPSAV
				JRST	MONENT;			GO TO MONITOR

		NEXT:		HRRZ	B,SEQ;			GET THE SEQUENCER
				EXCH	PP,PPSAV
				JRST	@BJSW(B);		DISPATCH TO PROPER SEQUENCE
		BJSW:		XWD	0,BJ1
				XWD	0,BJ2
				XWD	0,BJ3
				XWD	0,BJ4
				XWD	0,BJ5
				XWD	0,BJ7
				XWD	0,BJ9
; PG 112

BJ5:	MOVE	S,CUI;		RECOVER STATION #
	MOVE	D,[ASCII ? ON-?]
	TSX	DOF;		DISPLAY INITIALS ON TTY
	EXCH	PP,PPSAV
	JRST	INTBEG;		GO TO BEGINNING OF INTERPRET

BJ6:	AOS	SEQ
	SEND	BJM7;		"DEPARTMENT"
	JRST	BJSU

BJ7:	TSX	BJAD;		GO TO APPROVE DEPT
	JRST	BJ8;		NO GOOD
	SOS	SEQ;		OK EXIT
	JRST	BJ3.3

BJ8:	AOS	SEQ
	SEND	BJM8;		"DEPT NAME OR NUMBER"
	JRST	BJSU

BJ9:	TSX	BJAD;		TRY FOR APPROVAL AGAIN
	JRST	BJ8+1;		NO GOOD - KEEP AT HIM
	SOS	SEQ
	JRST	BJ7+2;		TAKE OK EXIT

; PG 113

BJA1:	MOVE	B,BLANKS
	MOVEM	B,INITIALS
	MOVEI	I,4;		MAX OF 4 LETTERS
	MOVEI	C,SCT1;		SCAN TABLE LOCATION
	MOVE	B,C3;		OUTPUT POINTER
	TSX	SCAN;		GO TO SCAN THE BUFFER
	CAIN	I,4;		NOT APPROVED IF NO INITIALS
	JRST	BJA4
	AOS	0(PP);		BUMP TO EXIT FOR APPROVED
	MOVE	B,INITIALS
	MOVE	C,CUI
	MOVEM	B,MINT(C);	SAVE IN MONITOR AREA
	DONE

BJA2:	POP	PP,0;		BUMP UP ONE LEVEL TO SCAN EXIT
	DONE;			TAKE NOT APPROVED EXIT

ALPH1:	SOSL	1;		ALPHA SCAN FOR INITIALS - COUNT CHARACTERS
	JRST	3(D);		ADD TO STRING

;	NOT APPROVED EXIT FOR INITIALS SCAN

BJA3:	POP	PP,0
BJA4:	MOVE	B,[ASCII /???  /]
	MOVEM	B,INITIALS;	RESTORE TEST CELL (FOR GOOD DRUM DATA)
	DONE;			TAKE NOT APPROVED EXIT

; PG 114

SCT1:	NOP;			BLANK
	JSP	D,ALPH1;	ALPHA
	JRST	BJA3;		NUMERIC
	JRST	BJA3;		SPECIAL
	JRST	BJA3;		ILLEGAL
	NOP;			PERIOD
	JRST	BJA3;		TAB
	NOP;			DASH
	JSP	D,END;		END OF STRING

DIGIT:	ANDI	C,17;		MASK TO NUMERIC
	JUMPN	A,DIG1;		JUMP IF NOT TESTING FOR LEADING ZEROS
	JUMPN	C,.+2;		IT IS NON-ZERO
	JRST	0(D);		IGNORE LEADING ZEROS
DIG1:	IMULI	A,^D10
	ADD	A,C;		CONSTRUCT BINARY RPN IN REG A
	ORI	C,60;		MAKE IT AND ASCII AGAIN
ALPHA:	SOSL	I;		COUNT CHARACTERS
DASH:	JRST	3(D);		ADD TO STRING
	JRST	BJA2;		MORE THAN 4 INITIALS, NOT APPROVED EXIT
END:	JRST	2(D);		EXIT FROM SCAN

; PG 115

BJA5:	MOVE	B,BLANKS
	MOVEM	B,JOBNO
	MOVEI	A,0;		PRESET LEADING ZERO SWITCH
	MOVEI	I,4;		MAX OF 4 DIGITS
	MOVEI	C,SCT2;		SCAN TABLE LOCATION
	MOVE	B,C4;		OUTPUT POINTER
	TSX	SCAN;		GO TO SCAN BUFFER
	MOVEM	A,SPARE1;	SAVE BINARY JOB NUMBER
	JUMPE	A,BJAN;		NO GOOD IF  ZERO
	CAIG	A,4;		1-4 ARE OK
	JRST	BJAY;		TAKE OK EXIT
	MOVEI	B,RPNS;		SIZE OF RPN RANGE TABLE
BJA5.2:	HLRZ	D,RPN-1(B);	LOW END OF OK RANGE
	CAMGE	A,D
	JRST	.+4
	HRRZ	D,RPN-1(B);	HIGH END OF OK RANGE
	CAMG	A,D
	JRST	BJAY;		ITS OK
	SOJG	B,BJA5.2;	GO FOR NEXT TABLE ENTRY

,	SEARCH SPECIAL TABLE

	MOVEI	B,SRPNS
BJS1:	LDB	D,PLOW
	JUMPE	D,BJS2;		IGNORE ZERO ENTRIES
	CAMGE	A,D
	JRST	BJS2
	LDB	D,PHIG
	CAMG	A,D
	JRST	BJS3
BJS2:	SOJG	B,BJS1
	JRST	BJAN;		NOT IN RANGE

,	HERE WE HAVE A JN IN OK RANGE

BJS3:	LDB	D,PSTN;		STATION NUMBER
	SKIPN	CUI
	JRST	BJS4;		ZERO IS OK
	CAME	D,CUI
	JRST	BJAN;		NOT ALLOWED ON THIS STATION
BJS4:	LDB	D,PDEP
	MOVEM	D,SPARE2;	SET DEPT NO.
BJAY:	AOS	0(PP);		BUMP TO APPROVAL EXIT
BJAN:	DONE

; PG 116

SRPN=.;		TABLE OF SPECIAL RPNS
	RADIX	10
	BYTE	(8) 78,^O5  (10) 950,974; SPARE
	BYTE	(8) 77,^O4  (10) 900,924; RAND,M BETHESDA
	BYTE	(8) 76,^O3  (10) 800,824; AFCRL
	BYTE	(8) 75,^O2  (10) 700,724; TAC LANGLEY, VS.
	BYTE	(8) 74,^O42 (10) 600,649; OSD
	BYTE	(8) 73,^O47 (10) 500,549; ARPA
	BYTE	(8) 72,^O43 (10) 400,449; AFCSA
	BYTE	(8) 71,^O37 (10) 300,399; AIR ACADEMY
	BYTE	(8) 70,^O33 (10) 200,299; SACRAMENTO
	RADIX	8
SRPNS=.-SRPN;	TABLE SIZE

PDEP:	POINT	8,SRPN-1(B),7
PSTN:	POINT	8,SRPN-1(B),^D15
PLOW:	POINT	10,SRPN-1(B),^D25
PHIG:	POINT	10,SRPN-1(B),^D35

,	TABLE OF LEGITIMATE RPN RANGES

	RADIX	10
RPN:	XWD	9900,9999
	XWD	9701,9899
	XWD	9660,9660
	XWD	9120,9550
	XWD	8210,8220
	XWD	7000,7130
	XWD	6701,6720
	XWD	5708,5735
	XWD	1001,1800
RPNS=.-RPN;
	RADIX	8

; PG 117

SCT2:	NOP;			BLANK
	JRST	BJA2;		ALPHA
	JSP	D,DIGIT;	NUMERIC
	JRST	BJA2;		SPECIAL
	JRST	BJA2;		ILLEGAL
	NOP;			PERIOD
	JRST	BJA2;		TAB
	JRST	BJA2;		DASH
	JSP	D,END;		END OF STRING

; PG 118

BJAD:	MOVE	B,[POINT 7,F];	OUTPUT POINTER
	MOVEI	C,SCT3;		CHAR TYPE EXECUTE TABLE
	SETZM	F
	SETZM	H,SPARE2
	SETZB	I,J
	TSX	SCAN
	JUMPE	I,BJA9;		JUMP IF NUMERICS RECEIVED
	AND	F,[BYTE (7) 137,137,137]; FORCE UPPER CASE
BJA7:	MOVEI	B,DEPTS;	GET SIZE OF DEPARTMENT TABLE
	MOVE	C,DEPT-1(B)
	AND	C,[BYTE (7) 177,177,177];  TAKE THREE CHARACTERS
	CAMN	C,F
	JRST	BJA8;		FOUND
	SOJG	B,BJA7+1;	LOOK FOR NEXT
	DONE;			NO GOOD

BJA8:	LDB	B,[POINT 7,DEPT-1(B),35]; GET DEPT NUMBER
	MOVEM	B,SPARE2;	SAVE IN	USER BLOCK
	AOS	0(PP);		BUMP TO APPROVAL EXIT
	DONE

BJA9:	MOVEI	B,DEPTS
	LDB	C,[POINT 7,DEPT-1(B),35]; GET DEPT NUMBER
	CAMN	C,H
	JRST	BJA8;		HE GOT ONE!
	SOJG	B,BJA9+1;	AROUND FOR NEXT
	DONE;			NONE FOUND - NOT OK

; PG 119

SCT3:	NOP;			IGNORE BLANKS
	JSP	D,BJD1;		ALPHA
	JSP	D,BJD2;		NUMERIC
	JSP	D,BJD1;		SPECIAL - TREAT AS ALPHA
	JRST	BJA2;		ILLEGAL - DENY
	NOP;			IGNORE PERIODS
	NOP;			IGNORE TABS
	NOP;			IGNORE DASH
	JSP	D,END;		END OF STRING

BJD1:	JUMPN	J,BJA2;		ALPHA SCAN - DENY IF PRIOR NUMERIC
	AOS	I
	CAIL	I,3;		NEED THREE ALPHAS
	JRST	1(D);		ENOUGH SEEN TO ADD TO STRING AND EXIST
	JRST	3(D);		ADD TO STRING

BJD2:	JUMPN	I,BJA2;		NUMERIC SCAN - BAD IF ALPHA
	ANDI	C,17;		MASK INTO NUMBER
	JUMPN	J,BJD22;	JUMP IF WE HAVE A DIGIT
	SKIPN	C
	JRST	0(D);		IGNORE LEADING ZEROS
BJD22:	IMULI	H,^D10
	ADD	H,C;		COMPUTE BINARY
	AOS	J
	CAIL	J,2;		NEED 2 DIGITS
	JRST	1(D);		ENOUGH
	JRST	3(D);		ADD TO STRING

; PG 120

	RADIX	10
DEPT:	BYTE	(21)"ADM"(15)23
	BYTE	(21)"AER"(15)32
	BYTE	(21)"AST"(15)35
	BYTE	(21)"COM"(15)81
	BYTE	(21)"COS"(15)11
	BYTE	(21)"CSD"(15)81
	BYTE	(21)"ELE"(15)33
	BYTE	(21)"ECO"(15)10
	BYTE	(7)"G",^O13,"A"(15)35;	LOWER CASE +
	BYTE	(7)"G",^O17,"A"(15)35;	LOWER CASE /
	BYTE	(21)"GEO"(15)35
	BYTE	(21)"LIB"(15)21
	BYTE	(21)"LOG"(15)12
	BYTE	(21)"MAT"(15)80
	BYTE	(21)"MFS"(15)20
	BYTE	(7)"M",^O12,"R"(15)26
	BYTE	(7)"M",^O17,"R"(15)26
	BYTE	(21)"PER"(15)28
	BYTE	(21)"PHY"(15)40
	BYTE	(14)"RD"(7)0(15)60
	BYTE	(21)"REP"(15)60
	BYTE	(21)"RES"(15)30
	BYTE	(21)"SEC"(15)27
	BYTE	(21)"SOC"(15)90
	BYTE	(21)"SSD"(15)90
	BYTE	(14)"SS"(7)0(15)90
	BYTE	(21)"SYO"(15)34
	BYTE	(21)"SYS"(15)34
	BYTE	(21)"WAS"(15)22
	BYTE	(14)"WO"(7)0(15)22
DEPTS=.-DEPT
	RADIX	8
; PG 121

;	C IS SCAN TABLE LOCATION, B IS OUTPUT BYTE POINTER LOCATION
;	E LEFT IS CLOBBERED, SCAN TABLE RETURNS ARE: 0=IGNORE CHAR
;	1=ADD TO OUTPUT STRING AN EXIT FROM SCAN, 2=EXT FROM SCAN
;	3=ADD CHARACTER TO OUTPUT STRING.

SCAN:	ADDI	E,3;		BUMP POINTER DOWN TO TEXT
	HRLI	E,440700;	INPUT BYTE POINTER
	MOVEM	E,SCP1
	SUBI	E,3;		RESTORE BUFFER POINTER
MSCAN:	JUMPE	B,.+2;		SKIP IF CONTINUING OUTPUT
	MOVEM	B,SCP3;		OUTPUT BYTE POINTER
	HRRM	C,SC9;		EXECUTE BYTE POINTER
SC3:	ILDB	B,SCP1;		LOAD NEXT INPUT BYTE
	MOVEM	B,C;		SAVE THE BYTE
	ANDI	B,7;		MASK LOW ORDER
	MOVNI	B,-8(B);	COMPUTE 8-(B)
	ASH	B,2;		4(8-(B))
	DPB	B,SCP4;		SET UP BYTE POINTER
	MOVEM	C,B;		RECOVER INPUT BYTE
	ASH	B,-3;		HIGH 4 BITS FOR INDEX
	LDB	B,SCP2;		GET THE TYPE
	XCT	@SC9;		EXECUTE THE SCAN TABLE INSTRUCTION
	JRST	SC3;		SKIP CHARACTER
	IDPB	C,SCP3;		ADD TO STRING AND EXIT
	DONE;			EXIT FROM SCAN
	IDPB	C,SCP3;		ADD CHARACTER TO OUTPUT
	JRST	SC3

; PG 122

,	TYPES ARE:
,		0=BLANK
,		1=ALPHA
,		2=NUMERIC
,		3=SPECIAL
,		4=ILLEGAL
,		5=PERIOD
,		6=COMMA
,		7=DASH
,		8=END OF STRING

,	THERE ARE EIGHT 4 BIT CODES PER WORD WITH 4 ZEROES AT
,	THE END OF EACH WORD.

CART:	BYTE	(4)8,4,4,4,4,4,4,4,0; COLUMN 1
	BYTE	(4)3,6,3,3,8,8,4,4,0
	BYTE	(4)4,4,4,4,4,4,4,4,0
	BYTE	(4)4,4,4,4,4,4,4,4,0
	BYTE	(4)0,3,3,3,3,3,3,3,0;	COLUMN 2
	BYTE	(4)3,3,3,3,3,7,5,3,0
	BYTE	(4)2,2,2,2,2,2,2,2,0
	BYTE	(4)2,2,3,3,3,3,3,3,0
	BYTE	(4)3,1,1,1,1,1,1,1,0;	COLUMN 3
	BYTE	(4)1,1,1,1,1,1,1,1,0
	BYTE	(4)1,1,1,1,1,1,1,1,0
	BYTE	(4)1,1,1,3,3,3,3,8,0
	BYTE	(4)4,1,1,1,1,1,1,1,0;	COLUMN 4
	BYTE	(4)1,1,1,1,1,1,1,1,0
	BYTE	(4)1,1,1,1,1,1,1,1,0
	BYTE	(4)1,1,1,4,4,4,4,4,0

; PG 123

EJ:	JRST	.+1
	MOVEI	B,EJ1
	MOVEM	B,INTENT;	SET NEXT ENTRY IN CASE WE DONT GET A BUFFER
	MOVE	B,PAGNO
	JUMPE	B,EJ3;		NO RECORD IF INITIALIZATION INCOMPLETE
	MOVEI	B,1;		GO TO MONITOR FOR A BUFFER
	JRST	MONENT

EJ1:	EXCH	PP,PPSAV
EJ2:	TSX	ISEC
	MOVEM	B,2(E);		SET OFF TIME IN ACCOUNTING RECORD
	CAMGE	B,ONTIME	
	ADDI	B,^D3600*^D24;	HE WORKS OVER THE WITCHING HOUR
	SUB	B,ONTIME;	COMPUTE SESSION TIME
	JSR	CVTL
	AOS	SESTIM(C);	INCREMENT PROPER COUNTER
	MOVEM	B,8(E);		SET IN ACCOUNTING RECORD
	ADDM	B,T7+4
	MOVE	B,[XWD ^D14,1];	COUNT AND TYPE FOR TAPE RECORD
	MOVEM	B,1(E)
	MOVE	C,[POINT 7,3(E)]
	XMT 12,DATE
	XMT 5, INITIALS
	MOVE	B,SPARE1;	BINARY PROJECT NUMBER
	MOVEM	B,6(E)
	MOVE	B,COMTIM

; PG 124

	MOVEM	B,7(E);		SAVE HIS COMPUTING TIME
	IDIVI	B,^D10;		SCALE BY 10 FOR DISPLAY
	JSR	CVTL
	AOS	CCTIM(C);	ACCUMULATE IN COMPUTE TIME DISTRIBUTION
	MOVE	S,CUI
	SETZM	MINT(S);	CLEAR MONITOR INITIALS
	MOVEM	S,^D9(E);	STATION  # TO ACCOUNTING RECORD
	MOVE	B,USIZE
	MOVEM	B,^D10(E)
	IMULI	B,^D6;		LOW END = 10 CELLS
	JSR	CVTL
	AOS	DSIZE(C);	COUNT IN SIZE DISTRIBUTION
	LDB	B,S.BLOCK
	MOVEM	B,^D11(E);	RECORD # OF CORE BLOCKS USED
	HRREI	S,-2;		GET CONTEXT FOR TAPE I/O
	MOVE	B,PAGNO
	MOVEM	B,^D12(E);	NUMBER OF PAGES OUTPUT TO ACCT RECORD
	MOVE	B,SPARE2
	MOVEM	B,^D13(E);	DEPT # TO ACCT RECORD
	MOVE	B,SPARE3;	CHARGE UNITS
	MOVEM	B,^D14(E)
	TSX	PUTB;		OUTPUT THE RECORD
	EXCH	PP,PPSAV
EJ3:	MOVEI	B,^D12;		TO MONITOR FOR FINAL OFF
	JRST	MONENT

; PG 125

,		CHANGES STATE OF USER IN S TO STATE IN E (AN
,		INDEX TO THE STATE TABLE)
,		CLOBBERS B, C, E, AND F.
CHS.:	LDB	B,S.STA;	CURRENT STATE
	CAMN	B,E
	DONE;			EXIT IF OLD STATE EQUALS NEW
	HRRZI	B,S.QUE(B);	ADDRESS OF HEADER
	MOVE	C,B;		SAVE POINTER TO HEADER
CHS1:	HRRZ	F,0(B);		CONTENTS OF ITEM
	JUMPN	F,.+2;		WE HAVENT GOT SOMETHING WRONG, HAVE WE?
H24:	HALT	24;		USER STATE AND QUEUE ARE DIFFERENT
	CAIN	F,S.Q(S);	DOES ITEM POINT TO DESIRED USER?
	JRST	CHS2;		YES
	HRRZI	B,0(F);		NEW ADDRESS OF ITEM
	JRST	CHS1
CHS2:	MOVE	F,0(F);		GET CELL TO BE UNLINKED
	HRRM	F,0(B);		TAKE OUT OF LIST
	TRNE	F,-1;		DID WE JUST MOVE UP THE LAST IN THE LIST?
	JRST	CHS2.5;		NO
	MOVEI	F,0(B);		ADDRESS OF LAST ON LIST
	HRLM	F,0(C);		END LINK TO HEADER
	CAMN	F,C;		DOES END LINK POINT TO HEADER?
	SETZM	0,(C);		YEA VERILY--ZERO IT OUT
CHS2.5:	DPB	E,S.STA;	UPDATE STATE

,	PUT ON NEW LIST

CHS4:	HRRI	E,S.QUE(E)
	SKIPN	B,0(E);		BRING UP LIST HEADER AND
	JRST	CHS5;		JUMP IF LIST IS EMPTY
	SKIPN	CSS;		SKIP IF LIST TOP SIGNAL IS ON
	JRST	CHS4.5;		NO--PUT ON BOTTOM OF LIST
	HRRM	B,S.Q(S);
	HRRI	B,S.Q(S);	NEW ITEM TO LIST TOP
	MOVEM	B,0(E);		RESTORE HEADER
	DONE

CHS4.5:	HLRZ	B,0(E);		GET ADDRESS OF END OF LIST
	MOVE	F,0(B);		GET LAST ITEM ON LIST
	HRRI	F,S.Q(S);	LINK IN CURRENT USER
	MOVEM	F,0(B);		PUT ON END OF LIST
	HRLM	F,0(E);		END LINK TO LIST HEADER
	HLLZS	S.Q(S);		ZERO LAST IN LIST
	DONE

CHS5:	MOVEI	F,S.Q(S);
	HRL	F,F;		LINK AS TOP OF QUEUE
	MOVEM	F,0(E)
	HLLZS	S.Q(S);		ZERO END ITEM
	DONE

; PG 126

,	STATION # IN REGISTER S RIGHT
;	INPUT IS POINTER TO BUFFER IN E RIGHT, ANYTHING IN LEFT
,	B IS SCRATCH REGISTER.  STARTS THE TRANSMISSION IF IT IS
,	THE ONLY BUFFER ATTACHED.

PUTB:	CONO	PI,1000+CHCTY;	TURN OFF THE TRAPS
	CAME	S,[DEC -2];	SKIP IF TAPE
	JRST	PUTB5;		NOT TAPE
	FSW B
	TRNE	B,TPQ;		QUIET TAPE SWITCH UP?
	JRST	PUTB4;		YES - RETURN BUFFER
	HRRZ	B,N.BUF
	CAIG	B,5;		FORGET TAPE OUTPUT IF FIVE OR
	JRST	PUTB4;		FEWER BUFFERS AVAILABLE
PUTB5:	HLRZ	B,S.BUF(S);	POINTER TO LAST BUFFER
	JUMPN	B,PUTB1;	JUMP IF BUFFERS ATTACHED
	HRL	E,E
	HLLZS	0(E);		ZERO LINK
	MOVEM	E,S.BUF(S);	NEW BUFFER HEADER.
	JUMPGE	S,PUTB2;	TEST FOR JOSS STATION OUTPUT
	CAMGE	S,[DEC -2];	IS THE RANGE OK?
H25:	HALT	25;		ILLEGAL I/O CONTEXT
	XCT	PUTB2(S);	DO THE START ROUTINE
	JRST	PUTB3
	TSX	CIO;		TAPE I/O START
	TSX	BIO;		CONSOLE TTY I/O START
PUTB2:	CALL	C27;		JOSS CONSOLE I/O START
	JRST	PUTB3
PUTB1:	MOVEM	E,0(B);		CHAIN NEW BUFFER TO LAST.
	HLLZS	0(E);		ZERO CURRENT BUFFER LINK
	HRLM	E,S.BUF(S);	LAST BUFFER POINTER TO BUFFER HEADER.
PUTB3:	CONO	PI,2000+CHDAT+CHCTY;	TURN ON THE TRAPS
	DONE
PUTB4:	TSX	MBA1;		GIVE BACK THE BUFFER
	JRST	PUTB3

; PG 127

;	EXITS +2 WITH BUFFER LOCATION IN E OR
;	      +1 IF NONE AVAILABLE.
;	USES ONLY REGISTER E.

GETBUF:	CONO	PI,1000+CHDAT+CHCTY;  TURN OFF THE TRAPS
	SOSL	N.BUF;		COUNT DOWN AVAIL BUFFER AND TEST
	JRST	GET1
	SETZM	N.BUF;		NONE AVAILABLE, EXIT 1
	JRST	GET2
GET1:	HRRZ	E,L.BUF;	POINTER TO TOP BUFFER
	HRR	E,0(E);		POINTER TO NEXT BUFFER
	HRL	E,L.BUF;	POINTER TO AVAIL BUFFER
	HRRM	E,L.BUF;	UPDATE HEADER
	TRNN	E,-1;		SKIP IF NOT LAST ON LIST
	SETZM	L.BUF;		LAST, SO ZERO ENTIRE HEADER
	HLRZ	E,E;		POINT TO BUFFER IN E RIGHT
	HLLZS	0(E);		ZERO LINK
	JUMPN	E,.+2
H11:	HALT	11;		ZERO CANT BE A BUFFER
	AOS	0(PP)
GET2:	CONO	PI,2000+CHDAT+CHCTY;  TURN ON THE TRAPS
	DONE;			TAKE EXIT 2

; PG 128

;	RETURNS BUFFER ATTACHED TO S TO AVAILABLE
;	CLOBBERS B,E

MBA:	CONO	PI,1000+CHDAT+CHCTY;  TURN OF THE TRAPS
	HRRZ	E,S.BUF(S);	GET BUFFER HEADER
	SKIPN	E
H12:	HALT	12;		ZERO CANT BE A BUFFER
	HRRZ	B,0(E);		GET LINK FROM ATTACHED BUFFER
	SKIPN	B;		SKIP IF NOT LAST ON LIST
	SETZM	S.BUF(S);	LAST, SO ZERO HEADER
	HRRM	B,S.BUF(S);	UPDATE HEADER
	CAIE	E,DBUF;		SKIP IF SPECIAL DISC BUFFER
	JRST	MBA1
	AOS	SKT;		FLAG OUTPUT COMPLETE
	JRST	MBA5;		AND DONT PUT ON AVAILABLE

;		RETURN BUFFER IN E TO AVAILABLE

MBA1:	CONO	PI,1000+CHDAT+CHCTY;  TURN OFF THE TRAPS
	HRRZ	B,L.BUF
MBA4:	CAMN	B,E;		THIS BUFFER SHOULD NOT BE ON THE LIST ALREADY
H13:	HALT	13;		BUT IT IS!!!
	JUMPE	B,.+3;		IF WE ARE AT THE END
	HRRZ	B,0(B);		GET THE NEXT ON THE LIST
	JRST	MBA4;		AND GOT TO TEST IT
	HLRZ	B,L.BUF;	ADDRESS OF LAST ON AVAILABLE
	JUMPE	B,MBA3;		ARE THERE NONE? JUMP IF SO.
	HRRM	E,0(B);		LINK OBJECT BUFFER TO LAST
MBA2:	HRLM	E,L.BUF;	AND TO HEADER
	SETZM	0(E);		ZERO HEADER OF OBJECT BUFFER
	AOS	N.BUF;		COUNT ONE MORE AVAILABLE
MBA5:	CONO	PI,2000+CHDAT+CHCTY;  TURN ON THE TRAPS
	DONE

MBA3:	HRRM	E,L.BUF;	SET UP FOR ONLY BUFFER ON LIST
	JRST	MBA2

; PG 129

;	ROUTINE AT CALLER + 1 IS EXECUTED TO FILL BUFFER
;		CLOBBERS S,E,C,B.

CMESS:	TSX	GETBUF
	JRST	CM1
	HRREI	S,-1;		CONSOLE OUTPUT CONTEXT
	MOVE	C,[POINT 7,1(E)]; POINT TO BUFFER
	XCT	@0(PP);		DO ROUTINE TO FILL THE BUFFER
	XMT 3,CRLF; TERMINATE THE BUFFER
	TSX	PUTB;		TRANSMIT IT
CM1:	AOS	0(PP);		BUMP TO EXIT
	DONE

; PG 130

,	ON ENTRY E IS  XWD MSGPTR,BUFFERPTR
,	B IS CLOBBERED, E IS UNCHANGED

BJ9.1:	HLRZ	B,E;		ADDR OF BLT CONTROL WORD IN MESSAGE
	MOVE	C,E;		SAVE BUFFER POINTER
	MOVE	B,0(B);		PICK UP XWD FIRST LOC, CT
	HLL	E,B;		FIRST LOC TO BLT CONT WORD
	ADDI	E,3;		BUMP TP TEXT LOCATION
	ADD	B,E;		CT + FIRST LOC = LAST WD + 1
	BLT	E,-1(B);	TRANSFER MSG TO BFR
	MOVE	E,C;		RESTORE BUFFER POINTER
	DONE

; PG 131
BJM1:	XWD	.+1,BJM1E-.
;	JOSS AT YOUR SERVICE, INITIALS PLEASE:
	BYTE	(7) 15,112,117,123,123,40,141,164,40,171;

	BYTE	(7) 157,165,162,40,163,145,162,166,151,143;

	BYTE	(7) 145,56,15,111,156,151,164,151,141,154;

	BYTE	(7) 163,40,160,154,145,141,163,145,72,40;

BJM1E:	BYTE	(7) 0;
BJM2:	XWD	.+1,BJM2E-.;	PROJECT NUMBER PLEASE:
	BYTE	(7) 120,162,157,152,145,143,164,40,156,165

	BYTE	(7) 155,142,145,162,72
BJM2E:	BYTE	(7) 40,0

BJM3:	XWD	.+1,BJM3E-.;	ONE TO FOUR LETTERS PLEASE:
	BYTE	(7) 117,156,145,40,164,157,40,146,157,165

	BYTE	(7) 162,40,154,145,164,164,145,162,163,40

	BYTE	(7) 160,154,145,141,163
BJM3E:	BYTE	(7) 145,72,40,0

BJM4:	XWD	.+1,BJM4E-.;	PLEASE USE A LEGITIMATE NUMBER:
	BYTE	(7) 120,154,145,141,163,145,40,165,163,145

	BYTE	(7) 40,141,40,154,145,147,151,164,151,155

	BYTE	(7) 141,164,145,40,156,165,155,142,145,162

BJM4E:	BYTE	(7) 72,40,0

BJM5:	XWD	.+1,BJM5E-.;	IF YOU ARE LEARNING USE "1" :
	BYTE	(7) 111,146,40,171,157,165,12,40,141,162

	BYTE	(7) 145,40,154,145,141,162,156,151,156,147

	BYTE	(7) 40,165,163,145,40,42,61,42,40,72

BJM5E:	BYTE	(7) 40,0

; PG 132

SDM:	XWD	.+1,BJM6E-.;	SYSTEM SHUTTING DOWN
	BYTE	(7) 15,123,171,163,164,145,155,40.163,150

	BYTE	(7) 165,164,164,151,156,147,40,144,157,167

BJM6E:	BYTE	(7) 156,56,15,0
BJM7:	XWD	.+1,BJM7E-.;	DEPARTMENT:
	BYTE	(7) 104,145,160,141,162,164,155,145,156,164

BJM7E:	BYTE	(7) 72,40
BJM8:	XWD	.+1,BJM8E-.;	DEPARTMENT NAME OR NUMBER:
	BYTE	(7) 104,145,160,141,162,164,155,145,156,164

	BYTE	(7) 40,156,141,155,145,40,157,162,40,156

	BYTE	(7) 165,155,142,145,162
BJM8E:	BYTE	(7) 72,40,0

; PG 133
	END
; PG 134

A		000000
ABG		002134'
ABG.S		000017
ACTION		006025' EXT
ADATE		007212' INT
ADIS		004650'
ALPH1		007624'
ALPHA		007652'
APRR		003766' INT
ATIM		000025'
B		000001
BBLOCK		000020
BEEPS		400000
BELF		004135'
BIO		003602'
BJ		007462'
BJ1		007514'
BJ2		007517'
BJ2.1		007524'
BJ3		007526'
BJ3.1		007531'
BJ3.2		007536'
BJ3.3		007534'
BJ4		007541'
BJ5		007562'
BJ6		007567'
BJ7		007572'
BJ8		007576'
BJ9		007601'
BJ9.1		010433'
BJA1		007605'
BJA2		007622'
BJA3		007626'
BJA4		007627'
BJA5		007656'
BJA5.2		007672'
BJA7		007773'
BJA8		010002'
BJA9		010006'
BJAD		007763'
BJAN		007723'
BJAY		007722'
BJD1		010025'
BJD2		010032'
BJD22		010037'
BJLEV		007546'
BJM1		010444'
BJM1E		010455'
BJM2		010456'
BJM2E		010462'
BJM3		010463'
BJM3E		010471'
BJM4		010472'
BJM4E		010501'
BJM5		010502'

; PG 135

BJM5E		010511'
BJM6E		010517'
BJM7		010520'
BJM7E		010523'
BJM8		010524'
BJM8E		010532'
BJS1		007702'
BJS2		007711'
BJS3		007713'
BJS4		007720'
BJSU		007545'
BJSW		007553'
BLANKS		004130'
BLKSWR		003332'
BLTC		005073'
BOF1		005521'
BOF10		005542'
BOF2		005525'
BOF3		005533'
BOF5		005536'
BOFF		005512'
BTA		004715'
BTA1		004722'
BU2		004437'
BUF		000403'
BUF1		004442'
BUFBIT		000004
BUFFER		004430'
BUFSIZ		000022
C		000002
C20		000000  EXT
C27		010332' EXT
C28		006602' EXT
C3		004136'
C30		004024' EXT
C31		006266' EXT
C32		004072' EXT
C4		004137'
C5		004140'
CAPR		000007 
CART		010131'
CCTIM		002262'
CCTY		000006 
CDAT		000006
CDC		000001
CDRM		000002
CH630		000030
CHAPR		000001
CHCTY		000002
CHDAT		000000
CHDC		000100
CHDRM		000040
CHECK		004141'
CHECK1		004151'
CHECK2		004176'

; PG 136

CHK1		004174'
CHK2		004206'
CHS.		010233'
CHS1		010240'
CHS2		010247'
CHS2.5		010257'
CHS4		010260'
CHS4.5		010271'
CHS5		010300'
CI630		000003
CIO		003475'
CIO1		003524'
CK		002130'
CK.S		000013
CKER		003162'
CKF		002114'
CKS10		003232'
CKS11		003233'
CKS5		003225'
CKS7		003231'
CKSUM		003207'
CL1		004055'
CL10		000036'
CL11		000037'
CL12		000040'
CL13		000041'
CL14		004075'
CL15		004104'
CL16		004120'
CL17		004125'
CL18		004014'
CL2		004057'
CL3		004051'
CL4		004025'
CL5		004015'
CL6		004063'
CL7		004065'
CL8		004010'
CL9		000035'
CLOCK		003771'
CM1		010431'
CMESS		010422' INT
CO.BUF		000330'
CO630		000004
COM		002124'
COM.S		000007
COMEBA		002111' INT
COMP1		005133'
COMP2		005140'
COMPAC		005122'
COMTIM		010201' EXT
CONSOL		005546' EXT
CONT		004355'
CONT1		004361'
CORBIT		000020

; PG 137

CORE		000272' INT
CPIL		002332'
CPOL		002344'
CR.R		006457'
CRLF		004134'
CRS		004133'
CSS		002113'
CT10		002156'
CT10A		002157'
CT11		002201' INT
CT12		002200'
CT13		002165' INT
CT14		002166' INT
CT15		002167' INT
CT16		002171' INT
CT17		002210' INT
CT18		002204' INT
CT18A		002205' INT
CT18B		002206' INT
CT19		002207' INT
CT19A		002203'
CT2		002162'
CT21		002224'
CT22		002226' INT
CT22A		002225' INT
CT23		002211' INT
CT24		002227' INT
CT25		002174'
CT26		002175'
CT27		002170'
CT27A		002176' INT
CT27B		002177' INT
CT28		002164' INT
CT2A		002174'
CT31		002173' INT
CT32		002160'
CT33		002161'
CT34		002162'
CT35		002163'
CT37		002172' INT
CT39		002202'
CT3A		002214'
CT41		002221'
CT42		002222'
CT43		002212'
CT44		002213'
CT45		002223'
CT46		002214' INT
CT47		002215' INT
CT48A		002216'
CT48B		002217'
CT48C		002220'
CT49		000320'
CT50		002230'
CT7		002221'

; PG 138

CT7A		002230'
CTD		006403' INT
CTD1		006414'
CTD2		006416'
CTDB		006405' INT
CTDR		006410' INT
CTPAR		002712'
CTPARS		000033
CTYR		003544' INT
CU		002125'
CU.S		000010
CUI		000021'
CVT1		006511'
CVTL		004262'
CVTL1		004267'
CVTLIN		006507'
CVTLOG		004251'
CVTS		000011
D		000003
D.TIME		003772' EXT
DAM		000001
DASH		007653'
DATE		000023' INT
DATIME		000000  EXT
DAY		000030' INT
DBASE		000321'
DBUF		010375' EXT
DCLOB		040000
DCLOBM		004577'
DCOMP		004625'
DCONT		004616'
DCONT1		004622'
DCP1		004635'
DCPI		002320'
DCT		002126'
DCT.S		000011
DDT		000000' EXT
DE10		003154'
DECT		003163'
DEDR		003164'
DEDR1		003165'
DEER		003126'
DELTA		000004
DEPT		010045'
DEPTS		000036
DERR		003133'
DI1		006646'
DI2		006653'
DI3		006661'
DI4		006663'
DIG1		007647'
DIGIT		007643'
DIP		002127'
DIP.S		000012
DISC		000000' EXT

; PG 139

DISC.C		006026' EXT
DISC.D		004667' EXT
DISC.S		007276' EXT
DISC1		005610'
DISC2		005600'
DISCP		005573'
DISINT		006645'
DISMIS		002745'
DKBIT		000010
DKBY		002110'
DM10		003113'
DM90		007322'
DMBY		002107'
DMERR		003137'
DMIBK		003324'
DMIN		003331'
DMNR		003305'
DMT		000020
DMUSR		003327'
DMWR		003330'
DOAF		000010
DOF		006664'
DOF1		006673'
DP		000010
DPWD		003325'
DPWD1		003326'
DQ		002131'
DQ.S		000014
DR		000400
DR2		003014'
DREQ		004604'
DREQ1		004613'
DRM10		003104'
DRM11		003105'
DRM12		003106'
DRM13		003107'
DRM14		003110'
DRM2		003037'
DRM3		002762'
DRM4.5		003031'
DRM5		003032'
DRM6		003033'
DRM6.5		003035'
DRM7		003043'
DRM7.5		003061'
DRM7.6		003077'
DRM7.7		003100'
DRM8		003102'
DRM9		003103'
DRMPP		003111'
DRMR		002750' INT
DSIZE		002274'
DSS		006101'
DSTAT		000020
DSTRT		004642'

; PG 140

DSU		002133'
DSU.S		000016
DT.BUF		000327'
DTIM		002306'
DUI		000002
DUMP		000000  EXT
E		000004
EJ		010151'
EJ1		010160'
EJ2		010161'
EJ3		010231'
END		007655'
END.S		000037
ENTSW		004327'
F		000005
F1		005476'
F2		005500'
F3		005507'
FAIL		003166'
FAKE		006171' EXT
FILE		004656' EXT
FIND		005472'
FINDB		005032'
FM		005152'
FM1		005153'
FM2		005161'
FM3		005163'
FM4		005173'
FM5		005174'
FM7		005203'
FRMT		007240'
G		000006
GET1		010350'
GET2		010363'
GETBUF		010343'
GETCT		006612'
GKM		004247'
GR		002132'
GR.S		000015
GR1		005614'
GR2		005616'
GR3		005621'
GRONK		005613'
GT1		006630'
GTI		005624'
H		000007
H1		007414'
H10		005603'
H11		010361'
H12		010370'
H13		010404'
H14		003235'
H15		002755'
H17		002777'
H2		004177'

; PG 141

H20		006224'
H21		006056'
H22		005453'
H23		004737'
H24		010242'
H25		010325'
H26		004215'
H27		004145'
H3		003713'
H30		007343'
H31		004156'
H33		004124'
H5		004325'
H6		006142'
H7		006520'
HALTS		020000
HDM		004535'
HEAD		002231'
HMES		007100' INT
HMES1		007103'
HR		000031' INT
HSDM		004571'
I		000010
IINT		002356'
IN10		006427'
IN11		006432'
IN20		006434'
IN30		006436'
IN40		006441'
IN50		006454'
IN99		006452'
INBIT		000002
INITIA		010176' EXT
INSR		003727'
INT1		007446'
INT2		007423'
INT3		007431'
INTBEG		007566' EXT
INTENT		010153' EXT
INTINT		007406'
IRPTR		004127'
ISEC		006421'
ISWAP		003333'
J		000011
JOBNO		007657' EXT
K		000012
K1		000074
K2		000054
K3		000017
KEY		004660' EXT
KILL		004162' INT
KILL1		007456'
L		000013
L.BUF		000402'
L.ETSW		000021

; PG 142

L.OPM		004562'
LASTB		002064'
M		000014
M1		005010'
M2		005100'
M25		005111'
M4		005116'
M5		005135'
M51		005143'
M52		005157'
MBA		010365'
MBA1		010401'
MBA2		010413'
MBA3		010420'
MBA4		010403'
MBA5		010416'
MDS		006007'
MDS2		006030'
MIN		000032' INT
MINT		002572'
MISC		002112'
MONE1		004351'
MONENT		004304' INT
MONEXI		004350'
MONS		007236'
MONTH		000027' INT
MOR1		005050'
MOR2		005033'
MOR2.5		005034'
MOR3		005041'
MOR3.5		005046'
MOR4		005052'
MOR41		005056'
MOR5		005064'
MOR51		005070'
MOR6		005020'
MOR7		005025'
MORC1		004764'
MORCI		005013'
MORCOR		004760'
MSCAN		010107'
MSGPR		005543'
MSGPR1		005555'
MT1		000224
MT2		000230
MTC		000220
N		000015
N.BUF		000401'
N.C		000313'
N.CB		000312' INT
N.CK		000323'
N.COR		000020
N.DRM		000320'
N.PP1		000020
N.S		000050  INT

; PG 143

N.SG		000050
N.SON		000324' INT
N.UC		000322'
NEXT		007550'
OCT		006700'
OCT1		006703'
OCTW		004274' INT
OCTW1		004276'
ODIS		006711'
OF		002140'
OF.S		000023
OF1		006302'
OF2		006304'
OFF		006276'
OFF5		006321'
OFFD		006323'
OFFNQ		006274'
OFFQ		006261'
OFFS		100000
OGKM		004211'
OINT		002370'
OLSW		000100
ON		002116'
ON.R		006326'
ON.S		000001
ON5		006337'
ONBIT		000040
ONTIME		010165' EXT
OPMSG		004563'
OSWAP		003234'
PAGE		004501'
PAGNO		010221' EXT
PATCH		000000'
PAUSE		004416'
PDEP		007735'
PG1		004557'
PG2		004550'
PG3		004544'
PG4		004551'
PHIG		007740'
PLOW		007737'
PP		000017
PP1		000121'
PPSAV		000020'
PPW		000120' INT
PQP		005561'
PQP2		005571'
PR1		003706'
PRMES		000040
PROG		004672' EXT
PROP		003673' INT
PRSIG		006134'
PSTN		007736'
PUTB		010305'
PUTB1		010334'

; PG 144

PUTB2		010332'
PUTB3		010337'
PUTB4		010341'
PUTB5		010316'
Q2		004465'
QC		002123'
QC.S		000006
QCTR		006604'
QDM		002136'
QDM.S		000021
QM		002137'
QM.S		000022
QM1		006371'
QM2		006377'
QM3		006403'
QM4		006373'
QP		002135'
QP.S		000020
QUIT		004446'
R2		003732'
R3		003735'
R4		003740'
R4.1		003750'
R4.99		003747'
RC		002117'
RC.S		000002
RCBIT		000001
RCOR		004726'
REBUF		004444'
RESK		006013'
RESULT		006033' EXT
RI		002120'
RI.S		000003
RIB		002121'
RIB.S		000004
RISIG		007434' EXT
RJD		003765' EXT
RPN		007741'
RPNS		000011
RSIG		005636' INT
RUL		005050'
RUL1		005052'
RUL2		005067'
S		000016
S.BLOC		000264'
S.BUF		000331' INT
S.COR		000263'
S.DU		000267'
S.GK		000270'
S.ID		000315'
S.INR		000266'
S.IU		000314'
S.M		000002
S.OFR		000265'
S.OK		000325' INT

; PG 145

S.Q		000141'
S.QUE		002115' INT
S.S		000211' INT
S.SIG		000271'
S.STA		000261'
S.TM		000262'
S.UD		000316'
S.UR		000317'
S10		005322'
S11		005324'
S12		005325'
SA		000112
SA1		006250'
SAQM		006246'
SC3		010112'
SC9		002155'
SCAN		010103'
SCP1		002151'
SCP2		002152'
SCP3		002153'
SCP4		002154'
SCT1		007632'
SCT2		007752'
SCT3		010014'
SDM		010512'
SDP		006104'
SDS		200000
SEC		000033' INT
SECOND		000044' INT
SELINT		007335'
SELSWP		005211'
SEQ		007603' EXT
SESTIM		002250'
SG		006560'
SG.L		000115' INT
SG.LIM		000117' INT
SG.M		000116' INT
SHUT		006126' EXT
SI1		007333'
SI2		007337'
SI3		007346'
SI3.5		007355'
SI4		007360'
SI4.5		007362'
SI7		007367'
SI8		007376'
SIGPR		007264' INT
SIGPR1		007264'
SIGTBL		000045' INT
SK1		006055'
SK10		006075'
SK11		006077'
SK2		006070'
SK3		006041'
SK4		006061'

; PG 146

SK5		006072'
SKR		006103'
SKT		006102'
SKULK		006032'
SOUT		007045' INT
SP1		006135'
SP2		006154'
SP3		006146'
SPARE1		010177' EXT
SPARE2		010223' EXT
SPARE3		010225' EXT
SPARE4		007441' EXT
SQM		006342'
SRPN		007724'
SRPNS		000011
SRR		005110'
SS1		005216'
SS10		005262'
SS11		005274'
SS15		005277'
SS17		005305'
SS18		005313'
SS2		005224'
SS3		005235'
SS30		005327'
SS32		005335'
SS33		005351'
SS34		005353'
SS35		005365'
SS4		005240'
SS40		005376'
SS41		005410'
SS42		005417'
SS44		005437'
SS45		005442'
SS5		005242'
SS6		005246'
SS90		005456'
SS98		005470'
SS99		005471'
SSIG		005650' INT
ST.1		007063'
ST.12		007077'
ST1		007114'
ST1A		007136'
ST1B		007115'
ST2		007141'
ST2.4		007157'
ST2.5		007131'
ST2.6		007135'
ST22		003574'
ST23		003575'
ST24		003576'
ST3		007243'
ST31		003577'

; PG 147

ST32		003600'
ST33		003557'
ST34		003555'
ST35		003601'
ST4		007246'
ST40		003572'
ST41		003612'
ST42		003627'
ST43		003643'
ST44		003652'
ST45		003660'
ST46		003664'
ST47		003665'
ST48		003666'
ST49		003667'
ST5		007254'
ST50		003670'
ST51		003671'
ST52		003672'
ST6		007256'
ST7		007263'
STA1		006775'
STA1.5		007025'
STA2		007043'
STA3		006762'
STAT		006737'
STAT1		006716'
STAT2		000020
SU		004372'
SU.5		004401'
SU1		004404'
SU2		004406'
SU3		004414'
SUM		002642'
SWITCH		010310' EXT
T.CU		000043'
T.MAX		000326'
T1		006200'
T10		002476' INT
T10.		002141'
T11		002510' INT
T11.1		002511' INT
T11.2		002512' INT
T11.3		002513' INT
T11.4		002514' INT
T11.5		002515' INT
T11.6		002516' INT
T11.7		002517' INT
T11.8		002520' INT
T11.9		002521' INT
T2		006173'
T3		006224'
T5		002414'
T6		002426'
T7		002440'

; PG 148

T7.9		002451' INT
T8		002452' INT
T80		007244' EXT
T80.99		007250' EXT
T9		002464' INT
TABO		007057'
TABO1		007062'
TAPES		003526'
TCW		003527'
TE1		005446'
TE2		005454'
TE20		003432'
TE21		003434'
TE22		003436'
TEND		003410'
TEND1		003424'
TEND2		003425'
TEND4		003444'
TEND5		003445'
TEND6		003446'
TEND7		003447'
TEND8		003450'
TEND9		003451'
TEND93		003452'
TEND95		003461'
TERASE		002222' INT
TERM		006130'
TERROR		002221'
TEST		005445'
TICK		000034'
TIME		000042' INT
TINT		002402'
TIP		003405'
TL		004366'
TLSU		004370'
TLT		004704'
TLT1		004706'
TO		006517'
TO1		006536'
TO3		006553'
TO99		006555'
TOCK		006542'
TOCK1		006552'
TODSU		006537'
TOF		002115'
TOF.S		000000
TPDL		003530'
TPQ		000004
TRST		003532'
TRST1		003541'
TSIG		005643' INT
TTT		005667'
TWAIT		003470'
TYPE6		000022' INT
U		000001

; PG 149

UC		002122'
UC.S		000005
UD2		007176'
UDATE		007162'
UP1		007212'
USERS		002160' INT
USIZE		010211' EXT
USTAT		002522'
V		000002
W		000003
WAIT		004420'
WJD		000000  EXT
X		000004
XMTR		003716'
Y		000005
YEAR		000026' INT
Z		000006
ZERO		004132'
ZZ		005050'

END OF ASSEMBLY
