	SUBTTL	PROVIDE MORE CORE FOR USERS BLOCK
;	PAGE 59

MORCOR:	MOVEI	B,0;		PRESET TO DENY REQUEST
	LDB	C,S.BLOCK;	CURRENT # OF BLOCKS
	CAML	C,N.CB;		COMPARE WITH MAX ALLOWABLE
	JRST	MONEXIT;	ENOUGH - DENY REQUEST
MORC1:	MOVE	D,[POINT 6,CT48A]
	ILDB	B,D
	SOJG	C,.-1;		COUNT DOWN TO PROPER BYTE
	SUBI	B,1
	DPB	B,D;		ONE LESS AT THIS SIZE
	ILDB	B,D
	ADDI	B,1
	DPB	B,D;		ONE MORE AT NEXT SIZE

,	IS BLOCK JUST ABOVE HIM FREE?

	LDB	C,S.BLOCK;	CURRENT # OF BLOCKS
	LDB	D,S.COR;	CURRENT BLOCK LOCATION
	SUBI	D,BBLOCK
	ADD	D,C;		INDEX TO NEXT HIGHER BLOCK
	AOS	C;		NUMBER OF REQUIRED BLOCKS
	CAML	D,N.C;		SKIP IF NOT TOP USER
	JRST	MOR6;		TO MOR1 FOR INCREASE IN CORE *******
	SKIPE	B,CORE(D);	SKIP IF BLOCK IDLE
	JRST	MOR6;		TO MOR1 TO INCREASE IN CORE************
	TLO	B,400000;	SET IN USE
	MOVEM	B,CORE(D)
	DPB	C,S.BLOCK;	NOW HE HAS ONE MORE

M1:	MOVEI	B,1;		TELL JOE HE GOT ONE
	TSX	SRR
	JRST	MONEXIT;	TELL INTERPRETER HE GOT ONE.

;	IMPERATIVE REQUEST FOR MORE CORE

MORCI:	LDB	C,S.BLOCK
	CAMGE	C,N.C;		SKIP IF TOO BIG FOR MACHINE
	JRST	MORC1
	MOVEI	B,0
	JRST	MONEXIT;	DENY REQUEST

,	NOW WE MUST SET UP A SWAP

MOR6:	DPB	C,S.BLOCK;	SET NEW SIZE
	SKIPN	DMBY;		SKIP IF DRUM IS BUSY
	JRST	MOR7
	CHS	QDM.S;		PUT ON QUEUE FOR OUT
	JRST	SIGPR

MOR7:	SUBI	C,1;		SIZE TO SHIP OUT
	SETOM	DMIN;		INDICATE NO USER IN
	TSX	OSWAP;		START HIM OUT
	CHS	QC.S;		PUT ON QUEUE TO COME BACK
	JRST	SIGPR


;	PAGE 60

;	FIND A FREE BLOCK OF CORE
;	  (OF REQUIRED SIZE ANYWHERE)

,	C- REQUIRED # OF BLOCKS, E IS DESTROYED
,	B= INDEX OF TOP FOUND BLOCK, D= CORE CELL (=0) OF LAST BLOCK
;	ROUTINE SKIPS ON NO SUCCESS

FINDB:	MOVEI	B,0
MOR2:	MOVEI	E,0
MOR2.5:	SKIPE	D,CORE(B)
	JRST	MOR3.5
	AOS	E
	CAMG	C,E;		IS BLOCK OF REQUIRED SIZE?
	DONE;			YES, TAKE SUCCESS EXIT
MOR3:	AOS	B
	CAMGE	C,N.C;		SKIP IF SEARCHED ALL BLOCKS
	JRST	MOR2.5
	AOS	0(PP);		BUMP TO NO SUCCESS EXIT
	DONE
MOR3.5:	MOVEI	E,0
	JRST	MOR3

ZZ=.


;	PAGE 61

;	FIND A FREE BLOCK OF THE REQUIRED SIZE
;	  (C = REQUIRED SIZE)

MOR1:	TSX	FINDB
	JRST	M2;		FOUND GO TO MOVE

,	FIND A FREE BLOCK BELOW USER

,	EXITS WITH B= INDEX TO FREE BLOCK

MOR4:	LDB	B,S.COR
	SUBI	B,BBLOCK
	JUMPE	B,MOR5;		JUMP IF NO BLOCKS BELOW
	SUBI	B,1
MOR41:	MOVE	D,CORE(B)
	TLNE	D,200000;	SKIP IF DRUM NOT USING BLOCK
	JRST	MOR5;		DRUM USING THIS AREA -- CANT TAMPER
	SKIPN	D
	JRST	M4;		FOUND ONE: GO TO MOVE
	SOJGE	B,MOR41;	GO FOR NEXT BLOCK


;	PAGE 62

,	FIND A FREE BLOCK ABOVE USER; C= # OF REQUIRED BLOCKS

MOR5:	LDB	B,S.COR
	SUBI	B,BBLOCK
	ADD	B,C;		START LOOKING ABOVE
	SUBI	B,2
MOR51:	CAML	B,N.C
	JRST	MOR6;		NONE , TRY SWAPS
	MOVE	D,CORE(B)
	TLNE	D,200000
	JRST	MOR6;		DRUM IS USING CORE
	SKIPN	D
	JRST	M5;		FOUND ONE: GO TO MOVE
	AOJA	B,MOR51;	GO TO LOOK AT NEXT BLOCK


;	PAGE 63

;	MOVE USER TO FREE AREA

,	C= # OF BLOCKS IN NEW USER AREA
,	B= CORE MAP INDEX OF LAST BLOCK IN "TO" REGION

M2:	TLO	D,400000;	BUSY THE HIGH BLOCK
	MOVEM	D,CORE(B)
	DPB	C,S.BLOCK;	NEW NUMBER OF BLOCKS
	SUBI	C,1;		BLOCKS TO MOVE
	SUB	B,C;		"TO" BLOCK LOCATION
	LDB	E,S.COR
	SUBI	E,BBLOCK;	INDEX OF "FROM" BLOCK
	MOVE	G,E;		SAVE "FROM" LOCATION
	TSX	BLTC;		MOVE USER AND CORE MAP
M25:	SETZM	CORE(G);	ZERO OLD MAP
	AOS	G
	SOJG	C,M25
	TSX	RUL;		RESET USER LOCATIONS
	JRST	M1;		SUCCESS RETURN TO JOE

;	MOVE DOWN MULTIPLE USERS (B=FREE BLOCK INDEX)

,	C= NEW SIZE

M4:	LDB	F,S.COR
	SUBI	F,BBLOCK
	DPB	C,S.BLOCK;	NEW SIZE
	ADD	C,F
	MOVE	A,C;		SAVE INDEX OF HIGH BLOCK
	SUBI	C,2
	SUB	C,B;		BLOCKS TO MOVE
	MOVE	E,B;		"TO" LOCATION
	ADDI	E,1;		"FROM" LOCATION
	TSX	BLTC;		MOVE USER
	TSX	RUL;		RESET LOCATION FOR AFFECTED USERS
	MOVEI	B,1
	EXCH	A,B
	DPB	A,S.IU;		BUSY THE FREED BLOCK
	JRST	M1;		BACK TO JOE


;	PAGE 64

,	MOVE USER(S) UP

,	B= FREE BLOCK INDEX, C= NEW SIZE

M5:	DPB	C,S.BLOCK;	SET NEW SIZE
	LDB	E,S.COR
	SUBI	E,BBLOCK
	ADD	E,C
	SUBI	E,1
	PUSH	PP,B;		SAVE FREE BLOCK LOCATION
M51:	MOVE	A,CORE-1(B)
	MOVEM	A,CORE(B);	MOVE THE CORE MAP
	SOS	B
	CAMLE	B,E
	JRST	M51
	MOVEI	C,1
	DPB	C,S.IU;		BUSY THE NEW BLOCK
	POP	PP,B
	ADDI	B,BBLOCK
	ASH	B,^D10
	ADDI	E,BBLOCK
	ASH	E,^D10;		LAST WORD TO BE MOVED
M52:	SOS	B
	MOVE	D,0(B)
	MOVEM	D,2000(B)
	CAMLE	B,E
	JRST	M52
	TSX	RUL;		RESET USER LOCATIONS
	JRST	M1;		RETURN TO JOE

RELOC	ZZ


;	PAGE 65

;	RESET USER LOCATIONS

,	SCAN CORE MAP AND UPDATE USER LOCATIONS

RUL:	EXCH	S,MISC
	MOVEI	B,0
RUL1:	SKIPN	E,CORE(B);	SKIP IF BUSY BLOCK
	AOJA	B,RUL2;		BUMP TO NEXT
	TLNE	E,200000
	AOJA	B,RUL2;		DONT MESS WITH DRUM CORE
	LDB	S,S.UR;		USER FOR THIS BLOCK
	MOVE	E,B
	ADDI	E,BBLOCK
	DPB	E,S.COR
	LDB	E,S.BLOCK
	LDB	F,S.STA
	CAIN	F,QDM.S
	SUBI	E,1
	ADD	B,E;		BUMP PAST THIS USER
RUL2:	CAMGE	B,N.C
	JRST	RUL1;		AROUND FOR NEXT
	EXCH	S,MISC
	DONE


;	PAGE 66

;	BLOCK TRANSFER CORE

,	MOVE BLOCKS DOWN - USERS AND CORE MAP
,		C= BLOCKS TO BE MOVED
,		B= "TO" BLOCK INDEX
,		E= "FROM" BLOCK INDEX
,	CLOBBERS F,E,B.

BLTC:	HRL	B,E;		BLT POINTER WORD
	MOVE	E,B
	ADD	E,C
	SUBI	E,1
	MOVE	F,B;		F MAY BE DESTROYED BY INTERRUPT
	ADD	F,[XWD CORE,CORE]
	BLT	F,CORE(E);	MOVE CORE MAP
	ADD	B,[XWD BBLOCK,BBLOCK]
	ASH	E,^D10
	ADDI	E,BBLOCK
	ASH	E,^D10
	BLT	D,2000-1(E)
	DONE

,	SET RELOCATION REGISTER

SRR:	LDB	D,S.COR
	ASH	D,^D10
	ADD	D,[OCT 100000700000];
	LDB	I,S.BLOCK
	SUBI	I,1
	ASH	I,^D10
	MOVSS	I
	ADD	D,I
	DATAO	APR,D;		SET RELOCATION
	DONE
