;PG 22
SUBTTL DATA CONTROL INTERRUPT ROUTINE

DISMIS: Z;			DATA CONTROL END ROUTINE
	CONO	PI,1000+CHDC;	TURN OFF CHANNEL
	JRST	12,@DISMIS

;PG 23
SUBTTL DRUM CHANNEL INTERRUPT ROUTINES

DRMR:	Z
	SETZM	DRM14;		IF ERROR, FLAG STORED HERE
	CONSZ	DP,100060;
	JRST	DEER;		MISSED DATA, NOEX MEM, OR PARITY ERROR
	SKIPN	DMBY
H15:	HALT	15;		SHOULD BE USING THE DRUM
	CONSO	DP,10
	JRST	DRM3
	CONO	DP,0;		KILL THE INTERRUPT
	JRST	12,@DRMR;	DISMISS END INTERRUPT FROM 167

DRM3:	EXCH	B,DRM9
	EXCH	C,DRM8
	CONSZ	DR,1000;	CHECK FOR ERROR
	JRST	DERR
	MOVEI	B,77777
	ANDM	B,DPWD1;	MASK OUT POSSIBLE HIGH CARRY BIT
	DATAI	DP,B
	CAME	B,DPWD1;	CHECK FOR GOOD
	JRST	DERR
	DATAI	DR,B
	CAME	B,DEDR1;	DRUM REGISTER ENDING CONTENTS
	JRST	DERR
	CONSO	DR,100
H17:	HALT	17;		NO JOB DONE FLAG
	CONO	DR,270;		DESELECT THE DRUM
	SETZM	DMBY
	SKIPN	DMWR;		SKIP IF WRITING
	JRST	10,DRM7;	MUST BE A READ
	SETZM	DECT;		ZERO THE ERROR COUNT

	WRITE END ROUTINE

	EXCH	S,DRM13
	MOVE	S,DMUSR
	MOVE	C,BLKSWRIT
	MOVE	B,DMIBK
	SETZM	CORE(B);	IDLE THE CORE JUST WRIT
	AOS	B
	SOJG	C,.-2
DR2:	AOS	N.DRM;		COUNT DRUM USERS
	SOS	CT39;		COUNT DOWN USERS IN CORE
	MOVE	B,DMNR;		GET LIST FOR OUT
	TLNE	B,777777;	SKIP IF NO MORE TO GO OUT
	JRST	10,DM10;	GO FOR NEXT WRITE
	SKIPE	SS98;		SKIP IF NO COMPACT REQUEST
	JRST	10,DRM2
	SKIPGE	S,DMIN;		SKIP IF SOME TO COME IN
	JRST	10,DRM4.5
	EXCH	PP,DRMPP
	TSX	ISWAP;		INITIATE IN TRANSFER
	EXCH	PP,DRMPP
	JRST	10,DRM5

;PG 24

;	INTERRUPT END SEQUENCE

DRM4.5: AOS	COMEBACK
DRM5:	EXCH	S,DRM13
DRM6:	EXCH	B,DRM9
	EXCH	C,DRM8
DRM6.5: AOS	CT19A;		COUNT DRUM ACTIONS
	JRST	2,@DRMR

DRM2:	AOS	SS99;		SET REQUEST FOR COMPACT OF CORE
	SETZM	SS98
	AOS	DMBY
	JRST	DRM4.5

;PG 25

;	READ END INTERRUPT

DRM7:	EXCH	S,DMIN
	EXCH	A,DRM14
	HRRZ	B,DMIBK
	ADDI	B,BBLOCK
	LDB	C,S.BLOCK
	LDB	A,S.STA
	CAIN	A,QC.S;		CHECK FOR EXPANDING SIZE
	SUBI	C,1
	JSR	CKSUM;		CHECKSUM THE BLOCK
	CAMN	A,SUM(S)
	JRST	DRM7.5;		GOOD
	EXCH	A,DRM14
	EXCH	S,DMIN
	JRST	DMERR
DRM7.5: SETZM	DECT
	EXCH	A,DRM14
	HRRZ	B,DMIBK
	DPB	S,S.UR
	ADDI	B,BBLOCK
	DPB	B,S.COR;	SET USER CORE LOCATION
	EXCH	A,DRM11;	SAVE REG AND GET A 2
	HRRZ	B,DMIBK
	LDB	C,S.BLOCK
	DPB	A,S.UD;		SET IN CORE AND NO DRUM USE
	AOS	B
	SOJG	C,.-2
	EXCH	A,DRM11
	AOS	CT39
DRM7.6: SOS	N.DRM
DRM7.7: EXCH	S,DMIN
	JRST	DRM6

; PG 26

DRM8:	Z;			SAVE FOR REG C
DRM9:	Z;			SAVE FOR REG B
DRM10:	OCT	1;		SAVE FOR REG A AND A ONE
DRM11:	OCT	2;		SAVE FOR REG A AND A TWO
DRM12:	Z
DRM13:	Z;			SAVE CELL FOR S
DRM14:	Z;			SAVE FOR A
DRMPP:	XWD	-2,.;		LOCAL PUSH REGISTER
	Z



,	INITIATE NEXT WRITE

,	B HAS PP REG FOR REQUEST LIST

DM10:	EXCH	PP,DRMPP
	POP	B,X;		GET NEXT TO WRITE
	LDB	C,S.BLOCK
	EXCH	D,DRM12
	MOVEM	B,DMNR
	EXCH	A,DRM14
	TSX	OSWAP;		START HIM OUT
	EXCH	A,DRM14
	EXCH	D,DRM12
	EXCH	PP,DRMPP
	JRST	DRM5

SUBTTL DRUM ERROR RECOVERY
; PG 27

;	DATA PROCESSOR ERRORS (PARITY, NOEX MEM, DATA MISS)

DEER:	EXCH	B,DRM9
	CONI	DP,B
	HRLM	B,DRM14
	CONO	DP,0
	EXCH	C,DRM8

;	OTHER HARDWARE ERRORS--DC FLAGS AND DATA REGISTER MISCOMPARE

DERR:	CONI	DP,B
	HRRM	B,DRM14;	SAVE FLAGS FOR DISPLAY
	CONO	DR,200270;	DISMISS DRUM
	JRST	10,DMERR

DMERR:	AOS	CT21;		COUNT DRUM ERRORS
	AOS	B,DECT
	CAILE	B,5
	JRST	FAIL
	AOS	DMBY
	SKIPN	DMWR;		SKIP IF WRITE
	JRST	DE10;		GO RECOVER READ ERROR
	CONO	DP,100+CDRM
	DATAO	DP,DPWD
	DATAO	DR,DEDR
	CONO	DR,260
	CONO	DR,220+CDRM
	JRST	DRM6

DE10:	CONO	DP,CDRM
	DATAO	DP,DPWD
	DATAO	DR,DEDR
	CONO	DR,260
	CONO	DR,230+CDRM
	JRST	DRM6

CKER:	Z;			SET IF A GRONKED USER
DECT:	Z;			ERROR RETRY COUNT
DEDR:	Z;			UNIT AND TRACK OF LAST SELECT
DEDR1:	Z;			EXPECTED ENDING TRACK AND SECTOR

; PG 28

;	CANT RECOVER DRUM ERROR--PREPARE TO GRONK USER

FAIL:	EXCH	S,DMIN
	EXCH	A,DRM14
	MOVEM	A,MINT(S);	SAVE FAILING CHECKSUM
	AOS	CKER;		FLAG ERROR OCCURRENCE
	MOVEI	A,1
	DPB	A,S.GK;		FLAG USER AS GRONKED
	EXCH	A,DRM14
	SETZM	DECT
	SETZM	DMBY
	SKIPE	DMWR
	JRST	DRM7.7
	LDB	C,S.BLOCK
	HRRZ	B,DMIBK
	SETZM	CORE(B);	FREE CORE
	AOS	B
	SOJG	C,.-2
	JRST	DRM7.6

SUBTTL CHECKSUM A USERS BLOCK
; PG 29

,		REPORTS ZERO CHECKSUM WHEN CKF IS ZERO
,		C,B CLOBBERED
,		S= USER #, C=BLOCKS TO SUM, B= LOCATION
CKSUM:	Z
	SKIPE	CKF
	JRST	.+3
	MOVEI	A,0
	JRST	2,@CKSUM
	ASH	C,^D10
	SUBI	C,1
	ASH	B,^D10
	HRRM	B,CKS7
	EXCH	7,CKS7
	EXCH	10,CKS10
	EXCH	11,CKS11
	MOVEI	A,0
	JRST	7
CKS5:	EXCH	7,CKS7
	EXCH	10,CKS10
	EXCH	11,CKS11
	JRST	2,@CKSUM


CKS7:	ADD	A,0(C)
CKS10:	SOJGE	C,7
CKS11:	JRST	CKS5

SUBTTL INITIATE TRANSFER TO DRUM
; PG 30

,	C= # OF BLOCKS TO WRITE
,	S= USER TO WRITE
,	DRUM LOCATIONS ARE FIXED BY USER - TWO TRACKS EACH,
,	SO THE MAX SIZE HANDLED IS 16K WORDS PER USER. B,D ARE CLOBBERED

OSWAP:	CONSZ	DR,100
H14:	HALT	14;		DRUM SHOULD BE FREE
	MOVEM	C,BLKSWRIT
	LDB	B,S.COR
	JSR	CKSUM
	MOVEM	A,SUM(S)
	MOVE	C,BLKSWRIT
	ASH	C,6
	MOVEM	C,DEDR1
	ASH	C,4
	MOVEM	C,DPWD1
	MOVE	C,BLKSWRIT
	HRRZ	D,C
	LSH	C,^D28
	MOVNM	C,DPWD;		WORDS TO MOVE
	LDB	B,S.COR
	SUBI	B,BBLOCK
	MOVEM	B,DMIBK;	SAVE LOCATION OF BLOCK WRITTEN
	MOVEI	C,1
	DPB	C,S.ID;		SET DRUM USE BIT
	AOS	B
	SOJG	D,.-2
	LDB	B,S.COR
	ASH	B,^D10
	DPB	B,S.COR;	MARK USER OUT OF CORE
	HRRM	B,DPWD;		FIRST WORD TO TRANSFER
	ADDM	B,DPWD1
	CONO	DP,100+CDRM;	SELECT FOR WRITE AND SET CHANNEL
	DATAO	DP,DPWD;	ACTIVATE I/O PROCESSOR
	HRRZ	B,S
	HRRZM	B,DMUSR
	ADD	B,DBASE
	ASH	B,^D10;		TRACK = 2&USER+DBASE
	MOVEM	B,DEDR;		SAVE UNIT AND TRACK FOR RECOVERY
	DATAO	DR,B;		SET UNIT AND TRACK
	CONO	DR,260;		SELECT UNIT
	CONO	DR,220+CDRM;	WRITE
	ADDM	B,DEDR1
	AOS	DMWR;		INDICATE DRUM WRITE
	AOS	DMBY
	DONE

SUBTTL DATA FOR DRUM TRANSFERS
; PG 31

DMNR:	XWD	0,.;		LIST OF USERS TO WRITE
	ZBLOK 16
DMIBK:	Z;			INCOMING BLOCK NUMBER
DPWD:	Z;			I/O CONTROL WORD
DPWD1:	Z;			EXPECTED END CONTENTS OF 167
DMUSR:	Z;			DRUM USER
DMWR:	Z;	SET WHEN WRITING
DMIN:	Z; RIGHT = USER TAGGED FOR IN, LEFT = PLACE IN QUEUE, NEG IF NO IN
BLKSWR: Z;			# OF BLOCKS WRITTEN

SUBTTL INITIATE TRANSFER FROM DRUM TO CORE
; PG 32

,	S HAS USER TO COME IN; DMIBK= CORE BLOCK FOR "IN"
,	S IS CLOBBERED

ISWAP:	LDB	C,S.BLOCK
	LDB	B,S.STA
	CAIN	B,QC.S;		CHECK FOR SIZE INCREASE
	SUBI	C,1
	MOVEM	S,DMIN
	MOVEM	C,S;		SAVE CORRECT BLOCK SIZE
	LSH	C,^D28
	MOVNM	C,DPWD;		WORD COUNT
	HRRZ	B,DMIBK;	GET IN LOCATION
	ADDI	B,BBLOCK
	ASH	B,^D10
	HRRM	B,DPWD;		FIRST WORD
	HRRZM	B,DPWD1
	HRRZ	B,DMIBK
	MOVE	C,S
	ASH	C,^D10
	ADDM	C,DPWD1
	MOVE	C,S
	ASH	C,6
	MOVEM	C,DEDR1
	MOVE	C,S
	EXCH	A,DRM10
	DPB	A,S.ID;		SET DRUM IN USE
	AOS	B
	SOJG	C,.-1
	SETZM	DMWR
	AOS	DMBY
	MOVE	S,DMIN;		RECOVER USER #
	ADD	S,DBASE
	ASH	S,^D10;		TRACK = 2&USER+DBASE
	CONO	DP,CDRM;	SAY READ AND ASSIGN CHANNEL
	DATAO	DP,DPWD;	ACTIVATE 167
	MOVEM	S,DEDR;		SAVE UNIT AND TRACK FOR RECOVERY
	CONO	PI,400;		PREVENT INTERRUPT FOR A WHILE
	DATAO	DR,S;		UNIT AND TRACK
	CONO	DR,260;		SELECT UNIT
	CONO	DR,230+CDRM;	READ
	EXCH	A,DRM10
	CONO	PI,200;		ON AGAIN
	ADDM	S,DEDR1;	EXPECTED END #
	HRRZS	DEDR1;		ZERO LEFT HALF
	DONE

